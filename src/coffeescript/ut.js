// coffeeScript.coffee: Generated by CoffeeScript 2.3.1 (coffeescript.coffee IMMED5 affects ./coffee -v)
(function() {
  // process: ENV={"node":true,"rn":false,"ut":true,"source":"/Users/pete/gitlab/rn/API/Flexbase/UT.coffee"}
  var B_FAIL_FAST, Base, EXPORTED, INFINITE_LOOP_DETECTION_ITERATIONS, O, S, T, TESTNBR, UT, UT_UT, Util, V, aGenerate, bHappy, bRan, bRunning, bag, decorate, decorateJustObject, fail, fnCallback, g_timer, handler, iterations, msStart, pass, path, proxyBag, sectionGenerate, t_depth, target, testGenerate, testIndex, testList, testListSaved, testStack, trace,
    indexOf = [].indexOf;

  INFINITE_LOOP_DETECTION_ITERATIONS = 200; //HC

  B_FAIL_FAST = false;

  T = true;

  /*			**MASTER**
  YAJUT - Yet Another Javascript Unit Test

  USAGE:
  yajut						run current configuration
  yajut conffile				run configuration stored as JSON in text file
  yajut list					list all tests in directory
  yajut purgelogs				forceably purge all previous log directories and files without user confirmation
  yajut resetstats			forceably reset all test statistics without user confirmation
  yajut -k keyword			run all tests matching keyword
  yajut -r					re-run all failed tests from the exact preceeding run
  yajut -s conffile			save current code-specified configuration into confifile for manual editing or re-use later

  EXTENDS: Base

  DESCRIPTION:
  The goal of JAJUT is to be absolutely the least-friction most-terse easiest to use JS unit test system.

  Promise-based, hierarchical test, minimalist and least-boilerplate, inline with source code unit test framework.

  - (ut) -> vs @utMethod: the value of 'ut' parameter is that:
      - @ form is shorter
      - but using ut: a test can use closure not fat arrows (=>) to access ut properties and methods
      - but using ut: if inside a overridden child method of a sub-class: onReceive where 'this' context is the object not the ut

  FEATURES
  -

  ERRORS:
  UT001 Unknown test option
  UT002 Unknown mType=#

  TODOs
  - ut() to fulfill async?
  - force to run all tests
  - create UT and UTRunner as they *are* different, right?
  - decorate section (s)
  - log EVERY run to new timestamp directory with tests ran in the directory name... store ALL data
  	- two files: currently enabled trace and ALL TRACE
  	- auto-zip at end
  	- directory: 2018-05-01 6m tot=89 P_88 F_1 3-TestClient,Store,DeathStar TR=UT_TEST_POST_ONE_LINER,ID_TRANSLATE.zip
  		traceSelected.txt
  		traceAll.txt
  		src/...
  - if run all TESTS report how many are disabled _
  - change ut to t
  - target=NODE_SERVER command line switch
  - put cleanup in opts  but that means @client and @server or implement our own timeout mechanism, again, inside here:
  - onPost -> @testHub.directoryRemoveRecursiveForce()
  - actually:  @testHub.directoryGetTempInstanceSpace
  - test auto-discovery so don't need to explicity list in tests.coffee
  - add @rnd() functions
  - add milepost functionality
  - validate system-level options parameter names
  - validate per-unit test on-the-fly options for mispellings
  - parallel mode: run as many tests in parallel as possible for speed.  If two can't run at same time then specify a mutex keyword {mutex:"db"}  but if create separate databases then shouldn't be a problem
  - @defined x
  - EXCEPTION to check the actual type of exception... many false positives/negatives unless do THAT
  - @db_log (snapshot)
  - @db_diff	do snapshot into delta arrays
  - only create tables once per section, and is run een if only a single test override in place... not sure how to pull this off.  @s -> if @testing ...
  - auto-teardown: you register setup things and what to do with them... if anything goes wrong they are torn down
  - write test results in JSON file so that can do "query" like "when was the last time this test passed?"
  - children ndoes that "build" to the current overridden child node... preceeding steps...really great idea!
  - designate test as a negative test... @tn... @n...  @an...?
  - @s {mutex: "ut"}           meaning, don't run this section concurrently with other ut mutex test
  - run all asynch tests at same time concurrently
  - classify tests: positive, negative, boundary, stress, unspecified, etc.
  - run all tests < or > than so many milliseconds
  - node -cat  show all unit tests
  - node -grep xxx   grep all matching tests
  - capitalize section ("S") overrides to run entire sections
  - purposeful 1000ms delay between tests to let things settle
  - count the number of disabled tests
  - include string diff report functions to make it really easy to ascertain why @eq fails
  #EASY: dump all possible test options... in grid with S T A section/test/asynch columns in front, option, desc, and example
  #EASY: new option def:
      @t "some test",
  			def:
  				em: "Deanna is beautiful"
  				b: "b-value"
  			exceptionMessage: @em			HOW DO THIS?
  		, ->
  			throw @em
      should be readable by ut.a, @a, and other parameters.  Ensure don't stomp on system

  KNOWN BUGS:
  -
   */
  //GITHUB: 
  //import Base
  Base = require('./Base');

  //import O
  O = require('./O');

  //import S
  S = require('./S');

  //import trace
  trace = require('./trace');

  //import Util
  Util = require('./Util');

  //import V
  V = require('./V');

  bHappy = true;

  g_timer = null;

  path = '';

  testStack = [];

  testList = [];

  testIndex = null;

  bRunning = null;

  iterations = null;

  testListSaved = null;

  t_depth = 0;

  pass = fail = 0;

  bRan = false;

  msStart = null;

  TESTNBR = null;

  fnCallback = null;

  bag = Object.create({
    clear: function() {
      var k;
      for (k in bag) {
        if (k !== "clear") {
          delete bag[k];
        }
      }
    }
  });

  //PATTERN: target is function
  target = function(cmdUNUSED_TODO) {
    var _, k, sans, v;
    if (trace.UT_BAG_DUMP) {
      //	console.log "HI: cmd=#{cmdUNUSED_TODO}"
      sans = Object.assign({}, bag);
      delete sans.clear;
      O.LOG(sans); //NOT-DEBUG
      if (_ = O.CNT_OWN(sans)) {
        console.log(`*** bag: ${_} propert${(_ === 1 ? "y" : "ies")}:`);
        for (k in sans) {
          v = sans[k];
          if (typeof v === "object") {
            console.log(`*** bag: ${k} =`);
            O.LOG(v);
          } else {
            console.log(`*** bag: ${k} = ${V.DUMP(v)}`);
          }
        }
      } else {
        console.log("*** bag: empty");
      }
    }
  };

  //PATTERN: target isn't actually proxy target
  handler = { // "traps"
    get: function(target, pn) {
      //		console.log "read from bag: #{pn} => #{bag[pn]}"
      return bag[pn];
    },
    set: function(target, pn, pv) {
      if (trace.UT_BAG_SET) {
        console.log(`proxy: set: ${pn}=${pv} <${typeof pv}>`);
      }
      if (pn === "clear") {
        throw "clear is not appropriate";
      }
      return bag[pn] = pv;
    }
  };

  proxyBag = new Proxy(target, handler);

  decorate = function(test, fn, testThis, parent) {
    var fn2;
    if (!fn) {
      console.error(`${test.tn}: function body is required`);
      fnCallback("exit-failure");
    }
    //	me2 = Object.create testThis
    decorateJustObject(test, testThis, parent);
    //	console.log "*** bRunToCompletion=#{testThis.bRunToCompletion}"
    return fn2 = fn.bind(testThis);
  };

  //REN me2 to testThis
  decorateJustObject = function(test, me2, parent) {
    var j, len, mn, ref, results;
    me2.t = T; // true	#TRACE
    me2.mState = this.STATE_SETUP;
    me2.test = test; //H
    me2.tn = test.tn;
    me2.opts = test.opts;
    me2.bag = proxyBag;
    me2.context = "CONTEXT set in decorateJustObject";
    //	me2.parent = parent		#H

    //	me2.one = "#{test.cname}/#{test.tn}"

    //METHODS
    me2.throw = function(v) {
      throw new Error(v);
    };
    me2.abort = function(msg) {
      return Util.abort(msg);
    };
    me2.assert = function(b, msg) {
      var _;
      _ = msg ? `: ${msg}` : "";
      this.logSilent(`assert: b=${b}${_}`);
      if (b) {
        pass++;
      } else {
        this.log(`ASSERTION FAILURE${_}`);
        fail++;
        if (B_FAIL_FAST) {
          Util.abort("B_FAIL_FAST");
        }
      }
      return b;
    };
    me2.defined = function(v, msg) {
      var _, b;
      _ = msg ? `: ${msg}` : "";
      this.logSilent(`defined: b=${b}${_}`);
      b = v != null;
      if (b) {
        //			console.log "defined"
        pass++;
      } else {
        this.log(`DEFINED FAILURE${_}`);
        fail++;
        if (B_FAIL_FAST) {
          Util.abort("B_FAIL_FAST");
        }
      }
      return b;
    };
    me2.delay = function(ms) {
      var to;
      to = {
        ms: ms,
        msActual: null,
        msBeg: Date.now(),
        msEnd: null
      };
      return new Promise((resolve) => {
        this.logg(trace.DELAY, `BEG: delay ${ms}`);
        return setTimeout(() => {
          to.msEnd = Date.now();
          to.msActual = to.msEnd - to.msBeg;
          this.logg(trace.DELAY_END, `END: delay ${ms} ********************************`, to);
          return resolve(to);
        }, ms);
      });
    };
    
    //REN: me2 is terrible name!
    me2.eq = function() {
      var _, bEQ, i, j, l, m, ref, ref1, ref2, s;
      bEQ = true;
      this.logSilent(`inside eq: arguments.length=${arguments.length}`);
      //		@log "ut: bRunToCompletion=#{@bRunToCompletion}"
      if (arguments.length >= 2) {
        this.logSilent(`arguments passed: arguments.length=${arguments.length}`);
        if (!(arguments[0] != null) && !(arguments[1] != null)) {
          this.logSilent("both undefined");
          return;
        }
        // typeS
        //			console.log "---CHECK typeS---"
        bEQ = true;
        _ = V.type(arguments[0]);
//			fnCallback "exit-failure"
        for (i = j = 0, ref = arguments.length - 1; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {
          //				@log "arg#{i}: #{V.PAIR arguments[i]} #{typeof arguments[i]}"
          //				@log "arg#{i}: #{V.PAIR arguments[i]} #{typeof arguments[i]} --> #{S.DUMP V.type(arguments[i]), true}"

          //				@log "#{_}-#{V.type arguments[i]}"
          if (_ !== V.type(arguments[i])) {
            bEQ = false;
          }
        }
        //					console.log "TTTTTTTTTT"
        //			console.log "aaa"
        if (!bEQ) {
          s = "@eq types violation:\n";
          for (i = l = 0, ref1 = arguments.length - 1; (0 <= ref1 ? l <= ref1 : l >= ref1); i = 0 <= ref1 ? ++l : --l) {
            s += `> arg${i}: ${V.type(arguments[i])}\n`;
          }
          //				@log "ut2: bRunToCompletion=#{@bRunToCompletion}"
          this.logError(s);
        }
        if (bEQ) {
          // VALUES
          //				console.log "---CHECK VALUES---"
          bEQ = true;
          _ = arguments[0];
          for (i = m = 0, ref2 = arguments.length - 1; (0 <= ref2 ? m <= ref2 : m >= ref2); i = 0 <= ref2 ? ++m : --m) {
            this.logSilent(`arg${i}: ${V.PAIR(arguments[i])} ${typeof arguments[i]}`);
            //WARNING: old code used to sometime hang node; it was very bizarre
            // unless _ is arguments[i]	#H
            //NOTE #REVELATION: "peter" NOT-EQUAL-TO new String "peter"
            // so force to string first!!!!!!!!!!!!!
            if ("" + _ !== "" + arguments[i]) {
              bEQ = false;
            }
          }
          //						console.log "i=#{i}: #{_}-#{arguments[i]}"
          if (!bEQ) {
            this.logError("@eq values violation!\n" + S.COMPARE_REPORT(arguments[0], arguments[1]));
          }
        }
      } else {
        throw new Error("eq: must pass at least two arguments");
      }
      if (bEQ) {
        pass++;
      } else {
        this.log("fail++");
        fail++;
        if (B_FAIL_FAST) {
          Util.abort("B_FAIL_FAST");
        }
      }
      return bEQ;
    };
    me2.eqfile_pr = function(a, b) { //CONVENTION
      return new Promise((resolve, reject) => {
        var size_a;
        size_a = null;
        return Util.size_pr(a).then((size) => {
          size_a = size;
          return Util.size_pr(b);
        }).then((size_b) => {
          this.eq(size_a, size_b);
          return resolve();
        }).catch((ex) => {
          return this.logCatch(ex);
        });
      });
    };
    me2.ok = function(v) {
      //		O.LOG_DRILL this, grep:"env"
      //		@env.succ()		
      return this.resolve(v);
    };
    me2.ex = function(ex) {
      console.log("aaaaa");
      this.logCatch(ex);
      console.log("bbbbb");
      this.reject(ex);
      return console.log("ccccc");
    };
    me2.fail = function(msg) {
      this.log("me2.fail");
      fail++;
      if (B_FAIL_FAST) {
        Util.abort("B_FAIL_FAST");
      }
      if (msg) {
        this.logError(msg);
      }
      return false; // so cal call @fail as last statement of onException, onTimeout, etc.
    };
    me2.fatal = function(msg) {
      //		console.error "fatal: #{msg}"
      clearInterval(g_timer);
      bHappy = false;
      bRunning = false;
      return Util.exit(msg);
    };
    //DUP
    me2.log = function() {
      if (trace.UT_TEST_LOG_ENABLED) {
        return Util.logBase.apply(this, [`${test.cname}/${test.tn}`, ...arguments]);
      }
    };
    me2.logError = function(s, o, opt) {
      //		console.log "logError: bRunToCompletion=#{@bRunToCompletion}"
      if (V.type(s) !== "string") {
        o = s;
        opt = o;
        s = "";
      }
      if (this.bRunToCompletion) {
        return Util.logBase(`${test.cname}/${test.tn}`, `ERROR: ${s}`, o, opt);
      } else {
        Util.logBase(`${test.cname}/${test.tn}`, `FATAL_ERROR: ${s}`, o, opt);
        return Util.exit("logError called with @bRunToCompletion=false");
      }
    };
    me2.logCatch = function(s, o, opt) {
      //		console.log "ooo #{@bRunToCompletion}"

      //RECURRING-ERROR: if V.type s  isnt "string"
      //RECURRING-ERROR: if V.type(s) isnt "string"
      if (V.type(s) !== "string") {
        //			console.log "SHIFT DOWN: V.type s => #{V.type s}"
        o = s;
        opt = o;
        s = "";
      }
      if (this.bRunToCompletion && !B_FAIL_FAST) {
        return Util.logBase(`${test.cname}/${test.tn}`, `CATCH: ${s}`, o, opt);
      } else {
        //			O.LOG "XXXXXXXXXXXXX", s, o, opt
        Util.logBase(`${test.cname}/${test.tn}`, `FATAL_CATCH: ${s}`, o, opt);
        //if node
        //			console.log "ooo #{@bRunToCompletion}"
        return this.abort("logCatch bRunToCompletion=false");
      }
    };
    //			throw new Error
    //endif
    me2.logFatal = function(s, o, opt) {
      if (V.type(s) !== "string") {
        o = s;
        opt = o;
        s = "";
      }
      Util.logBase(`${test.cname}/${test.tn}`, `FATAL: ${s}`, o, opt);
      return Util.exit();
    };
    me2.logSilent = function(s, o, opt) {
      return Util.logBase(`${test.cname}/${test.tn}`, s, o, {
        bVisible: false
      });
    };
    me2.logTransient = function(s, o, opt) {
      if (this.bRunToCompletion) {
        return Util.logBase(`${test.cname}/${test.tn}`, `TRANSIENT: ${s}`, o, opt);
      } else {
        Util.logBase(`${test.cname}/${test.tn}`, `FATAL_TRANSIENT: ${s}`, o, opt);
        return Util.exit("logError called with @bRunToCompletion=false");
      }
    };
    //	me2.logWarning	= (s, o, opt)		->	Util.logBase "#{test.cname}/#{test.tn}", "WARNING: #{s}", o, opt
    //	me2.logWarning	= (s, o, opt)		->	Util.logBase.apply this, ["#{test.cname}/#{test.tn}", "WARNING2", arguments...]
    me2.logWarning = function(s, o, opt) {
      return Util.logBase.apply(this, [`${test.cname}/${test.tn}`, "WARNING2", ...arguments]);
    };
    me2.pass = function() {
      pass++;
      return true; // so can call @pass() as last statement of onException, onTimeout, etc.
    };
    
    //	O.LOG_DRILL test.parent
    //	for v in Object.getOwnPropertyNames test.parent
    //		console.log "==> #{v}"
    //	for k,v of test.parent
    //		console.log "==> #{k}"
    //		if me2[k]
    //			throw "You are not allowed to define the method named '#{k}' because it clashes with a built-in property"

    //	k = "alloc"
    //	me2[k] = test.parent[k]

    //	O.LOG "test.parent", test.common
    if (test.common) {
      ref = test.common;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        mn = ref[j];
        //		console.log "==> #{mn}"
        if (me2[mn]) {
          throw `You are not allowed to define the method named '${mn}' because it clashes with a built-in property`;
        }
        results.push(me2[mn] = test.parent[mn]);
      }
      return results; //R
    }
  };

  aGenerate = (cmd) => {
    return function(tn, fn) {
      var opts;
      //		console.log "$$$$$$$$$$$$$0 #{arguments[0]}"
      //		console.log "$$$$$$$$$$$$$1 #{arguments[1]}"
      //		console.log "$$$$$$$$$$$$$2 #{arguments[2]}"
      //		console.log "$$$$$$$$$$$$$3 #{arguments[3]}"
      if (Object.prototype.toString.call(fn) === '[object Object]') {
        opts = fn;
        fn = arguments[2];
      }
      if (typeof fn !== "function") {
        Util.abort("MISSING fn");
      }
      if (bRunning && t_depth === 1) {
        this.logFatal(`NESTED t: the parent of '${tn}' is also a test; change to 's' (section)`);
      }
      //		@log "found async: #{tn} --> #{@__CLASS_NAME}"

      //		if cmd is "A"
      //			O.LOG_DRILL this
      //			this.alloc "peter"

      //		@log "CLASS=#{@__CLASS_NAME}  TN=#{tn} ===> PATH=#{path}"
      //		@log "#{@__CLASS_NAME}#{path}/#{tn}"

      //H: combine	#DUP
      return testList.unshift({
        bEnabled: false,
        cmd: cmd,
        cname: this.__CLASS_NAME,
        tn: tn,
        fn: fn,
        one: `${this.__CLASS_NAME}/${tn}`,
        opts: opts != null ? opts : {},
        parent: this,
        common: Object.getOwnPropertyNames(Object.getPrototypeOf(this)).filter(function(mn) {
          return mn !== "constructor" && mn !== "run";
        }),
        path: `${this.__CLASS_NAME}/${path}/${tn}`
      });
    };
  };

  //		console.log "********** aGenerate: #{path}"

  //		if tn is "alloc objectInsert"
  //			o = Object.getPrototypeOf this
  //			a = Object.getOwnPropertyNames o
  //			for pn in a
  //				@log pn	#, this[pn]
  //			O.LOG_DRILL o, true
  //			Util.abort()
  //		@log "xxxxxxxxxxx", Object.getOwnPropertyNames Object.getPrototypeOf(this)
  testGenerate = (cmd) => {
    return function(tn, fn) {
      var opts;
      if (Object.prototype.toString.call(fn) === '[object Object]') {
        opts = fn;
        fn = arguments[2];
      }
      if (typeof fn !== "function") {
        Util.abort("MISSING fn");
      }
      if (bRunning) {
        if (++t_depth === 2) {
          this.abort(`NESTED t: the parent of '${tn}' is also a test; change to 's' (section)`);
        }
        fn();
        return --t_depth;
      } else {
        //			console.log "found test: #{tn}: cmd=#{cmd}"
        return testList.unshift({
          bEnabled: false,
          cmd: cmd,
          cname: this.__CLASS_NAME,
          tn: tn,
          fn: fn,
          one: `${this.__CLASS_NAME}/${tn}`,
          opts: opts != null ? opts : {},
          parent: this,
          path: `${this.__CLASS_NAME}/${path}/${tn}`
        });
      }
    };
  };

  //			console.log "********** testGenerate: #{path}"
  sectionGenerate = (cmd) => {
    return function(tn, fn) {
      var opts;
      if (typeof tn !== "string") {
        throw 0;
      }
      if (typeof fn !== "function") {
        throw 0;
      }
      if (Object.prototype.toString.call(fn) === '[object Object]') {
        opts = fn;
        fn = arguments[2];
      }
      if (typeof fn !== "function") {
        Util.abort("MISSING fn");
      }
      if (bRunning && t_depth === 1) {
        Util.abort(`NESTED t: the parent of '${tn}' is also a test; change to 's' (section)`);
      }
      //		@log "found section: #{tn}"
      testStack.push(tn);
      path = testStack.join('/');
      //		console.log "BEG: sectionGenerate: #{path}"
      fn.bind(this)({
        one: `${this.__CLASS_NAME}/${tn}`,
        opts: opts != null ? opts : {},
        parent: this, //H
        tn: tn
      });
      testStack.pop();
      return path = testStack.join('/');
    };
  };

  //		console.log "END: sectionGenerate: #{path}"

  //H: overloaded between UT runner and superclass
  EXPORTED = UT = (function() {
    class UT extends Base {
      constructor(argv = ["", ""], bRunToCompletion = false, opts1 = {}, fnCallback1 = (function() {}), WORK_AROUND_UT_CLASS_NAME_OVERRIDE) {
        var ref;
        super("I DO NOT UNDERSTAND WHY I CANNOT PASS @__CLASS_NAME HERE and I don't know why it works when I don't!!!");
        this.argv = argv;
        this.bRunToCompletion = bRunToCompletion;
        this.opts = opts1;
        this.fnCallback = fnCallback1;
        this.WORK_AROUND_UT_CLASS_NAME_OVERRIDE = WORK_AROUND_UT_CLASS_NAME_OVERRIDE;
        //		console.log "UT CONSTRUCTOR IMPLICIT CALL: #{@WORK_AROUND_UT_CLASS_NAME_OVERRIDE} #{@constructor.name}"
        //		@log "bRunToCompletion=#{@bRunToCompletion}"
        //		O.LOG @opts
        fnCallback = this.fnCallback;
        this.__OPTS = this.opts; //HACK
        this.__CLASS_NAME = (ref = this.WORK_AROUND_UT_CLASS_NAME_OVERRIDE) != null ? ref : this.constructor.name;
        testIndex = "pre";
        bRunning = false;
      }

      //COMMAND: asynchronous test
      _A(a, b, c) {}

      _a(a, b, c) {}

      A(a, b, c) {
        return aGenerate('A').bind(this)(a, b, c);
      }

      a(a, b, c) {
        return aGenerate('a').bind(this)(a, b, c);
      }

      //COMMAND: section / directory of tests
      _S(a, b, c) {}

      _s(a, b, c) {}

      S(a, b, c) {
        return sectionGenerate('S').bind(this)(a, b, c);
      }

      s(a, b, c) {
        return sectionGenerate('s').bind(this)(a, b, c);
      }

      //COMMAND: synchronous test
      _T(a, b, c) {}

      _t(a, b, c) {}

      T(a, b, c) {
        return testGenerate('T').bind(this)(a, b, c);
      }

      t(a, b, c) {
        return testGenerate('t').bind(this)(a, b, c);
      }

      argsProcess(a) {
        var er, i, item, optionList, pattern;
        optionList = [
          {
            o: "-all",
            d: "force all tests to be run (ignore individual test overrides)"
          },
          {
            o: "-grep pattern",
            d: "NOT-IMP: -l but only show matching lines"
          },
          {
            o: "-h",
            d: "help"
          },
          {
            o: "-l",
            d: "list all tests"
          },
          {
            o: "-t a,b,c,...",
            d: "NOT-IMPL: trace: only turn on specified traces"
          },
          {
            o: "-tn",
            d: "trace No: turn off all trace"
          },
          {
            o: "-ty",
            d: "trace Yes: turn on all trace"
          },
          {
            o: "<number>",
            d: "test number from 1 to the (number of tests)"
          }
        ];
        er = function(msg) {
          console.log(msg);
          return fnCallback("exit-success");
        };
        i = 0;
        while (i < a.length) {
          item = a[i++];
          switch (item) {
            case "-all":
              this.__OPTS.allForce = true;
              break;
            case "-grep":
              pattern = a[i++];
              er(S.autoTable(testList, {
                bHeader: true,
                grep: pattern,
                ignore: "bEnabled,common,fn,parent,path,one,opts"
              }));
              break;
            case "-h":
              er(`node tests.js [options]\n\nOPTIONS:${S.autoTable(optionList, {
                bHeader: false
              })}`);
              break;
            case "-l":
              //			bEnabled: false
              //			cmd: cmd
              //			cname: @__CLASS_NAME
              //			tn: tn
              //			fn: fn
              //			one: "#{@__CLASS_NAME}/#{tn}"
              //			opts: opts ? {}
              //			parent: this
              //			common: Object.getOwnPropertyNames(Object.getPrototypeOf(this)).filter (mn) -> mn not in ["constructor","run"]
              //			path: "#{@__CLASS_NAME}#{path}/#{tn}"
              er(S.autoTable(testList, {
                bHeader: true,
                ignore: "bEnabled,common,fn,parent,path,one,opts"
              }));
              break;
            case "-tn":
              this.__OPTS.traceOverride = false;
              T = false;
              break;
            case "-ty":
              this.__OPTS.traceOverride = true;
              break;
            default:
              if (Number.isInteger(item * 1)) {
                TESTNBR = item * 1;
              } else {
                er(`UT: Illegal option: "${item}"`);
              }
          }
        }
        if (TESTNBR && this.__OPTS.allForce) {
          return er("Can't specity both -all and #");
        }
      }

      next() {
        var _, bExpectException, bRestore, bWasException, ex, failSave, fnBoundObjectThis, handle, passSave, prNOT_USED, ref, ref1, rv, test, testThis;
        if (!bRunning) {
          return;
        }
        //SCARY	objectThis = this
        //		O.LOG objectThis
        //		@abort()

        //H: is this while loop even used anymore?
        while (testIndex < testList.length) {
          //			console.log "TEMP: #{testIndex} < #{testList.length}"
          //			if iterations++ > INFINITE_LOOP_DETECTION_ITERATIONS
          //				@logFatal "infinite loop detected (stopped at #{iterations} iterations)"
          iterations++;
          this.assert(iterations < INFINITE_LOOP_DETECTION_ITERATIONS, `infinite loop detected (stopped at ${iterations} iterations)`);
          //EASY: @assert
          //			@log "#{testListSaved} VS #{testList.length}"
          if (testListSaved !== testList.length) {
            this.logFatal("testList corruption");
          }
          if (TESTNBR && TESTNBR !== (testIndex + 1)) {
            this.post(null, null);
            return;
          }
          test = testList[testIndex];
          test.opts = Object.assign({}, this.__OPTS, (ref = this.__OPTS) != null ? (ref1 = ref.perTestOpts) != null ? ref1[test.cname] : void 0 : void 0, test.opts);
          delete test.opts.perTestOpts;
          //			O.LOG "next.opts:", test.opts
          if (fail) {
            Util.abort("something failed");
          }
          // iter=#{iterations}
          this.logg(trace.UT_TEST_PRE_ONE_LINER, `================== #${testIndex + 1} ${test.path // ##{testIndex+1}/#{testList.length} #{test.cname} #{test.cmd}:#{test.tn}#{if trace.DETAIL then ": path=#{test.path}" else ""}"
}`);
          if (test.bRun) {
            this.logFatal("already run!");
          } else {
            test.bRun = true;
          }
          test.msBeg = Date.now();
          //EXPERIMENTAL
          //SCARY
          //						O.LOG test.parent
          //						@abort()
          testThis = Object.assign({}, test.parent);
          switch (test.cmd) {
            case 'a':
            case 'A':
              handle = null;
              prNOT_USED = new Promise((resolve, reject) => {
                var ex, fn2, ms, rv;
                //						@log "ASYNC #{test.cname} #{test.tn} PATH=#{test.path}"	# type=#{typeof test.fn} fn=#{test.fn}"
                testThis.resolve = resolve;
                testThis.reject = reject;
                //H: not multi-threaded!
                testThis.resolve = resolve;
                testThis.reject = reject;
                testThis.testIndex = testThis.testIndex = testIndex;
                this.fnCallback("pre", "a", testThis, this.__OPTS);
                fn2 = decorate(test, test.fn, testThis, this);
                //						decorateJustObject test, testThis, this

                //						O.LOG testThis
                ms = testThis.opts.hang ? 2147483647 : testThis.opts.timeout;
                // @log "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ setting timer: #{ms}ms"
                handle = setTimeout(() => {
                  var bExpectTimeout, fnBoundObjectThis;
                  bExpectTimeout = false;
                  if (test.opts.onTimeout != null) {
                    fnBoundObjectThis = decorate(test, test.opts.onTimeout, testThis, this);
                    bExpectTimeout = fnBoundObjectThis(testThis);
                  }
                  //									@log "a: bExpectTimeout=#{bExpectTimeout}"
                  if (bExpectTimeout || test.opts.expect === "TIMEOUT") {
                    resolve();
                    return;
                  }
                  this.log(`[[${test.path}]] TIMEOUT: ut.{resolve,reject} not called within ${ms}ms in asynch test`);
                  fail++;
                  if (B_FAIL_FAST) {
                    Util.abort("B_FAIL_FAST");
                  }
                  return reject("TIMEOUT");
                }, ms);
                try {
                  return rv = fn2(testThis);
                } catch (error) {
                  //EXPERIMENTAL
                  //							@log "rv=#{Object::toString.call rv}"
                  //							if Object::toString.call(rv) is "[object Promise]"
                  //#								@log "interpretting Promise"
                  //								rv.then (resolved) =>
                  //									@log "FOUND RESOLVED PROMISE"

                  //									#DUP: with below... put in subroutine
                  //									if resolved
                  //										@logg trace.UT_RESOLVED, "#{test.one} result", resolved
                  //									clearTimeout handle
                  //									pass++

                  //									if fail and !@bRunToCompletion
                  //										@log "if fail and !@bRunToCompletion"
                  //										Util.abort "fail=#{fail}"
                  //										fnCallback "exit-failure"

                  //									@post test, "a-then: #{test.cname}/#{test.tn}"
                  //								.catch (ex) =>
                  //									@logCatch "CATCH", ex
                  ex = error;
                  clearTimeout(handle);
                  //YES_CODE_PATH
                  this.logCatch(`async exception in '${test.cname}/${test.tn}'`, ex);
                  if (!this.bRunToCompletion) {
                    return this.fnCallback("exit-failure");
                  }
                }
              }).then((resolved) => {
                if (resolved) {
                  this.logg(trace.UT_RESOLVED, `${test.one} result`, resolved);
                }
                clearTimeout(handle);
                pass++;
                if (fail && !this.bRunToCompletion) {
                  this.log("if fail and !@bRunToCompletion");
                  this.fnCallback("exit-failure", `fail=${fail}`, testThis);
                }
                return this.post(test, `a-then: ${test.cname}/${test.tn}`);
              }).catch((ex) => {
                this.log("catch: REJECT CALLED DURING ASYNC", ex);
                clearTimeout(handle);
                //						if ex is "TIMEOUT" and test.opts.expect is "TIMEOUT"
                //							pass++
                //							@post test, "a-expect-TIMEOUT"
                if (ex !== "TIMEOUT") {
                  this.log("fail++ NOT TIMEOUT");
                  fail++;
                  if (B_FAIL_FAST) {
                    Util.abort("B_FAIL_FAST");
                  }
                  this.logCatch("a-cmd", ex);
                }
                if (!this.bRunToCompletion) {
                  return this.fnCallback("exit-failure", `fail=${fail}`, testThis);
                }
                return this.post(test, "a-catch"); //IMPORTANT
              });
              return;
            case 't':
            case 'T':
              // @log "RUNNING #{test.tn} PATH=#{test.path} pass=#{pass} fail=#{fail}"#" #{test.fn}"
              passSave = pass;
              failSave = fail;
              try {
                if (++t_depth === 2) {
                  this.logFatal(`[${test.path}] nested tests`);
                }
                testThis.testIndex = testThis.testIndex = testIndex;
                this.fnCallback("pre", "t", testThis, this.__OPTS);
                //						O.LOG "objectThis", objectThis
                fnBoundObjectThis = decorate(test, test.fn, testThis, this);
                rv = fnBoundObjectThis(testThis);
                if (Object.prototype.toString.call(rv) === "[object Promise]") {
                  this.logFatal("promise returned from synchronous: wrong test command: use async instead of synchronous");
                }
                //						@log "back from test"
                if (fail > failSave && test.opts.expect === "ERROR") {
                  //							@log "RESTORE: expect=ERROR: eliminate: pass=#{pass} fail=#{fail}"
                  pass = passSave;
                  fail = failSave;
                }
                this.fnCallback("post", "t", testThis, this.__OPTS);
                //						@log "say something meaningful here"										if trace.UT_TEST_POST_ONE_LINER	
                if (test.opts.expect === "EXCEPTION") {
                  // shouldn't be here
                  this.logError("expected exception but didn't get one!!!");
                  fail++;
                  if (B_FAIL_FAST) {
                    Util.abort("B_FAIL_FAST");
                  }
                } else if (pass === passSave) {
                  // implicit pass
                  pass++;
                }
                --t_depth;
                this.post(test, "t"); //WARNING: could cause very deep stack
              } catch (error) {
                ex = error;
                //						@log "t-catch ------", ex		#URGENT 
                --t_depth;
                bWasException = true;
                bExpectException = false;
                bRestore = false;
                if (test.opts.onException != null) {
                  fnBoundObjectThis = decorate(test, test.opts.onException, testThis, this);
                  bExpectException = fnBoundObjectThis(testThis);
                }
                //							@log "t: bExpectException=#{bExpectException}"
                if (bExpectException || test.opts.expect === "EXCEPTION") {
                  bWasException = false;
                  bRestore = true;
                  if (test.opts.exceptionMessage != null) {
                    //								@log "ex", ex
                    //								@log ""+ex
                    if (ex.message !== (_ = test.opts.exceptionMessage)) { //BRITTLE?
                      this.log("WRONG EXCEPTION MESSAGE!");
                      this.log('^' + S.COMPARE_REPORT(ex.message, _, {
                        preamble: "ex.message\n\ntest.opts.exceptionMessage"
                      }));
                      bWasException = true;
                    }
                  }
                }
                if (bWasException) {
                  fail++;
                  if (B_FAIL_FAST) {
                    Util.abort("B_FAIL_FAST");
                  }
                  this.logCatch(`[${test.path}] t-handler`, ex);
                } else {
                  if (bRestore) {
                    //								@log "restore: eliminate: pass=#{pass} fail=#{fail}"
                    pass = passSave;
                    fail = failSave; // restore fail's from eq failures
                  }
                  if (pass === passSave) {
                    // implicit pass
                    pass++;
                  }
                }
                this.post(test, "t-catch");
              }
              return;
            case 's':
            case 'S':
              this.post(null, "s");
              return;
            default:
              this.logFatal(`unknown cmd=${test.cmd}`);
          }
        }
      }

      //			@log "bottom of while"
      //		@log "UT-DONE ##{testIndex}/#{testList.length}"
      post(test, who) {
        //		throw new Error "WTF?"
        if (test) {
          test.msEnd = Date.now();
          test.msDur = test.msEnd - test.msBeg;
          this.logg(trace.UT_DUR, `${test.msDur}: ${test.path}`);
        }
        //		@log "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ post: who=#{who} ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
        if (Base.openCntGet()) {
          Base.logOpenMap();
          Util.abort("INTERMEDIATE RESOURCES LEFT OPEN!");
        }
        if (++testIndex === testList.length) {
          //			@log "UT-DONE: who=#{who}"
          return bRunning = false;
        } else {
          //			@log "post: next: who=#{who}"
          return this.next();
        }
      }

      //			if g_timer
      //				@next()
      //			else
      //				console.error "g_timer is null"
      run() {
        var cmd, cmds, j, k, l, len, len1, mTypeCtrList, opts, ref, ref1, summary, test;
        this["@who"] = "UNIT TEST RUNNER";
        this.argsProcess(this.argv.slice(2));
        this.fnCallback("init", "UT", null, this.__OPTS);
        this.stackReset();
        //		@log "run"
        //		O.LOG_DRILL this, true
        mTypeCtrList = [0, 0];
        for (j = 0, len = testList.length; j < len; j++) {
          test = testList[j];
          if (opts = test.opts) {
            //				@log "opts", opts
            if (opts.exceptionMessage && (opts.expect == null)) {
              opts.expect = "EXCEPTION";
            }
            cmds = ["desc", "exceptionMessage", "expect", "hang", "human", "internet", "mType", "onError", "onException", "onTimeout", "SO", "RUNTIME_SECS", "timeout", "url", "USER_CNT"];
            for (l = 0, len1 = cmds.length; l < len1; l++) {
              cmd = cmds[l];
              cmds.push('_' + cmd);
            }
            for (k in opts) {
              if (indexOf.call(cmds, k) < 0) {
                this.logFatal(`[[${test.path}]] UT001 Unknown test option: '${k}'`, opts);
              }
            }
            if ((opts.onTimeout || opts.timeout) && ((ref = test.cmd) !== "_a" && ref !== "a" && ref !== "_A" && ref !== "A")) {
              this.logFatal(`[[${test.path}]] asynch opt not allowed with '${test.cmd}' cmd`, opts);
            }
            if (opts.mType != null) {
              //					@log "********", opts.mType
              if ((0 <= (ref1 = opts.mType) && ref1 <= 1)) {
                mTypeCtrList[opts.mType]++;
              } else {
                this.logFatal(`[[${test.path}]] UT002 Unknown mType=${opts.mType}`, opts);
              }
            }
          }
        }
        summary = `[NEG=${mTypeCtrList[0]} PROOF=${mTypeCtrList[1]}]`;
        return new Promise((resolve, reject) => {
          var bFoundOverride;
          if (bRunning) {
            throw 0;
          }
          if (bRan) {
            throw 0;
          }
          bRan = true;
          msStart = Date.now();
          //			@log "run: test count=#{testList.length}"
          if (testList.length > 0) {
            testList.reverse();
            testIndex = 0;
            while (testIndex < testList.length) {
              test = testList[testIndex];
              //				@log "pre: ##{testIndex} #{test.cmd}:#{test.tn}: #{test.path}"
              testIndex++;
            }
            testIndex = 0;
            bRunning = true;
            iterations = 0;
            bFoundOverride = false;
            testList.forEach((test) => {
              if (/^[A-Z]/.test(test.cmd)) {
                //						@log "found ut override: #{test.tn}"
                test.bEnabled = true;
                return bFoundOverride = true;
              }
            });
            if (this.__OPTS.allForce) {
              bFoundOverride = false;
            }
            testListSaved = testList.length;
            if (bFoundOverride && (TESTNBR == null)) {
              testList = testList.filter((test) => {
                return test.bEnabled;
              });
              //					@log "test", a:"a", false
              //					@log "test", a:"a", true
              //					@log "ONE", "TWO", "THREE"
              //					Util.abort "NOW"

              //					fn = (a, b) ->
              //						O.LOG arguments
              //					fn "a", "b"
              this.log(`${summary} Found ${testListSaved} test${(testListSaved === 1 ? "" : "s")} with ${testList.length} override${(testList.length === 1 ? "" : "s")}`);
            }
            if (testList.length > 0) {
              testListSaved = testList.length;
              this.next();
              //HACK: utilize this timer to keep node running until all tests have completed
              return g_timer = setInterval(() => {
                var i, m, ref2, s, secs;
                if (!bRunning) {
                  if (bHappy) {
                    secs = Math.ceil((Date.now() - msStart) / 1000);
                    this.log("======================================================");
                    this.log(`${Base.openMsgGet()}  All unit tests completed: [${secs} second${(secs === 1 ? "" : "s")}] total=${pass + fail}: ${(!fail ? "PASS" : "pass")}=${pass} ${(fail ? "FAIL" : "fail")}=${fail}`);
                    clearInterval(g_timer);
                    if (Base.openCntGet()) {
                      //PARAMS: eventName, primative, objectThis
                      this.fnCallback("left-open", "ut", this);
                    }
                    if (fail) {
                      return resolve(`[${secs}s] fail=${fail}`);
                    } else {
                      if (trace.TRACE_DURATION_REPORT && testList.length) {
                        s = `\nTests longer than ${trace.TRACE_DURATION_MIN_MS}ms:`;
                        testList.sort(function(a, b) {
                          if (a.msDur > b.msDur) {
                            return -1;
                          } else {
                            return 1;
                          }
                        });
                        for (i = m = 0, ref2 = testList.length - 1; (0 <= ref2 ? m <= ref2 : m >= ref2); i = 0 <= ref2 ? ++m : --m) {
                          test = testList[i];
                          if (test.msDur > trace.TRACE_DURATION_MIN_MS) {
                            if (s) {
                              console.log(s);
                              s = null;
                            }
                            console.log(`> ${test.msDur}: ${test.tn}     ${test.path}`);
                          }
                        }
                      }
                      return resolve(`[${secs}s] pass=${pass}`);
                    }
                  }
                }
              }, 100);
            }
          }
        });
      }

      stackReset() {
        testStack.length = 0;
        return path = '';
      }

      static s_ut() {
        return new UT_UT().run();
      }

    };

    UT.prototype.NEG = 0;

    UT.prototype.PROOF = 1;

    UT.prototype.STATE_SETUP = 0;

    UT.prototype.STATE_RUN = 1;

    UT.prototype.STATE_TEARDOWN = 2;

    return UT;

  }).call(this);

  UT_UT = class UT_UT extends UT {
    run() {
      //		@t "UT events", (ut) ->
      //			@eq ut.say_hi_to_peter, "Hi Pete!"
      //			@testHub.startClient "/tmp/ut/UT_UT"
      //			.then (client) =>
      //				@log "one: #{client.one}"
      //			.catch (ex) =>
      //				@logCatch "startClient", ex		#H: logCatch WHAT should be the parameter?
      this.t("opts", function(ut) {
        this.log("ut.opts=", ut.opts);
        this.eq(ut.opts.aaa, "AAA");
        this.log("@opts=", this.opts);
        return this.eq(this.opts.aaa, "AAA");
      });
      this.t("empty log", function() {
        this.log("pre");
        if (trace.HUMAN) {
          this.log();
          this.log();
          return this.log("post");
        }
      });
      this.s("bag", function() {
        this.t("set", function() {
          this.bag();
          this.bag.color = "red";
          return this.bag();
        });
        this.t("get", function() {
          this.bag();
          this.eq(this.bag.color, "red");
          this.bag.clear();
          this.eq(this.bag.color, void 0);
          return this.bag();
        });
        return this.t("clear invalid", function() {
          var ex;
          try {
            this.bag.clear = "this should fail";
            return this.fail("it's illegal to assign 'clear' to bag");
          } catch (error) {
            ex = error;
            return this.pass();
          }
        });
      });
      this.s("sync nesting test", function() {
        //			@log "SYNC"
        //			t = 0
        //			@log "div 0"
        //			t = t / t
        //			O.LOG this
        //			@log "hello"
        return this.s("a", (ut) => {
          //				@log "section log"
          //				@logError "section logError"
          //				@logCatch "section logCatch"
          this.s("b1", function(ut) {
            this.t("b1c1", function(ut) {});
            //						@log "test log"
            //						@logError "test logError"
            //						@logCatch "test logCatch"
            return this.t("b1c2", function(ut) {});
          });
          return this.s("b2", function(ut) {
            return this.s("b2c1", function(ut) {
              return this.t("b2c1d1", function(ut) {});
            });
          });
        });
      });
      this.s("async nesting test", function(ut) {
        return this.s("a", function(ut) {
          this.s("b1", function(ut) {
            this.a("b1c1", function(ut) {
              return setTimeout((() => {
                return ut.resolve();
              }), 10);
            });
            //						@log "setTimeout"
            //						@log "asynch log"
            //						@logError "asynch logError"
            //						@logCatch "asynch logCatch"
            return this.a("b1c2", function(ut) {
              return ut.resolve();
            });
          });
          return this.s("b2", function(ut) {
            return this.s("b2c1", function(ut) {
              return this.a("b2c1d1", function(ut) {
                return ut.resolve();
              });
            });
          });
        });
      });
      this.s("options", function() {
        this.s("general", function() {
          return this.t("commented out", {
            _desc: "this is not used"
          }, function() {});
        });
        return this.s("specific", function() {
          this.t("exceptionMessage", {
            exceptionMessage: "Deanna is beautiful"
          }, function() {
            throw new Error("Deanna is beautiful");
          });
          this.s("expect", function() {
            this.t("assert", {
              expect: "ERROR"
            }, function() {
              this.log("hello");
              this.assert(true, "Saturday");
              return this.assert(false, "Sunday");
            });
            this._t("bManual: fatal", {
              comment: "can't test because it exits node",
              bManual: true
            }, function() {
              //						TODO: skip if bManual is true
              this.fatal();
              return this.fatal("display me on console");
            });
            return this.a("promise timeout", {
              timeout: 10,
              expect: "TIMEOUT"
            }, function(ut) {});
          });
          //						DO NOT CALL ut.resolve()
          this.a("onTimeout", {
            timeout: 10,
            onTimeout: function(ut) {
              this.log(`onTimeout called: ${ut.opts.timeout}=${this.opts.timeout}`);
              return true;
            }
          }, function(ut) {
            return this.log("do not call ut.resolve to force timeout");
          });
          this.a("timeout", {
            timeout: 1000
          }, function(ut) {
            //							@log "opts parameter"
            //							O.LOG ut.opts
            this.eq(ut.opts.timeout, 1000);
            return ut.resolve();
          });
          return this._t("seek exception but don't get one", {
            expect: "EXCEPTION",
            bManual: true
          }, function() {
            return this.log("hello");
          });
        });
      });
      this.s("eq", function() {
        //UT: two pass
        //UT: two fail
        //UT: third parameter description supported
        this.t("single parameter", {
          onException: function(ut, ex) {
            //					@log "in onException"
            return this.pass();
          }
        }, function() {
          return this.eq("I feel alone");
        });
        this.t("differing types", {
          desc: "@eq is NOT strict, i.e, it checks VALUE only (string vs. String is okay and passes"
        }, function() {
          //				@log "in test: *** bRunToCompletion=#{@bRunToCompletion}"
          return this.eq("peter", new String("peter"));
        });
        return this.s("HELP WHY CAPITALIZED? Eq", function() { //H: why repeat
          this.t("single parameter", {
            onException: function(ut, ex) {
              //					@log "in onException"
              return this.pass();
            }
          }, function() {
            return this.Eq("I feel alone");
          });
          return this.t("differing types", {
            expect: "EXCEPTION",
            desc: "@Eq is strict!, i.e., VALUE and TYPE must agree!"
          }, function() {
            //				@log "in test: *** bRunToCompletion=#{@bRunToCompletion}"
            return this.Eq("peter", new String("peter"));
          });
        });
      });
      this.a("@delay", function(ut) {
        this.log("before");
        this.delay(50).then((to) => {
          this.log("timed out", to);
          return ut.resolve(to);
        }).catch((ex) => {
          return this.logCatch("CATCH", ex);
        });
        return this.log("after");
      });
      this.t("one", function(ut) {
        this.log();
        this.log(`one: ${this.test.one}`);
        return this.eq(this.test.one, "UT_UT/one");
      });
      return this.s("misc", function() {});
    }

  };

  //			@A "don't close", (ut) ->
  //				@log "something doesn't stop"
  module.exports = EXPORTED;

}).call(this);
