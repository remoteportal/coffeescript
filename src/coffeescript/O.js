// Generated by CoffeeScript 2.4.1
(function() {
  /*
  O - Object Functions					*** PROJECT AGNOSTIC ***

  WHAT: Node module

  DESCRIPTION

  FEATURES
  -

  NOTES
  -

  TODOs
  - LOG: pass explicit opts
  - LOG: maxDepth option
  - LOG: look at arguments.length to see if any passed parameters are undefined or null and PUT IN ALL CAPS!
  - LOG: Object.getOwnProperty to show hidden (non-enumerable) properties
  - #	log "#{["1st","2nd","3rd","4th","5th","6th","7th","8th","9th","next","next","next"][objectFoundNbr++]} OBJ PASSED", v, 0
  - O.DUMP with opts map
  - NEXT: abort if legs repeated in path

  KNOWN BUGS:
  -
  */
  var A_CLR_ENUM, CLR_ENUM, CNT, CNT_ENUM, CNT_ENUM_OWN, CNT_OWN, CONTAINS_INSENSITIVE, DEEP, DEEP_DNW, DEEP_OPPOSITE, DEEP_TOO_MUCH_WORK, DFS_BREAKABLE, DUMP, IS_EMPTY, KEYS, KEYS_ENUM, KEYS_ENUM_OWN, KEYS_OWN, LOG, LOG_DRILL, O, SUMMARY, V, duck, g_LOGIgnore, trace;

  //if node
  trace = require('./trace');

  V = require('./V');

  O = require('./O');

  //endif
  g_LOGIgnore = {};

  //MOVE: to pre-processor
  //H: what are the differences between these?
  //UT: UT-ize
  CNT = function(o) {
    var a;
    a = [];
    while (true) {
      a.push.apply(a, Object.getOwnPropertyNames(o));
      if (!(o = Object.getPrototypeOf(o))) {
        break;
      }
    }
    return a.length;
  };

  CNT_OWN = function(o) {
    if (o) {
      return Object.getOwnPropertyNames(o).length;
    } else {
      throw new Error("CNT_OWN: object is null!");
    }
  };

  CNT_ENUM = function(o) {
    var k, n;
    n = 0;
    for (k in o) {
      n++;
    }
    return n;
  };

  CNT_ENUM_OWN = function(o) {
    return Object.keys(o).length;
  };

  KEYS = function(o) {
    var a;
    a = [];
    while (true) {
      a.push.apply(a, Object.getOwnPropertyNames(o));
      if (!(o = Object.getPrototypeOf(o))) {
        break;
      }
    }
    return a;
  };

  KEYS_OWN = function(o) {
    return Object.getOwnPropertyNames(o);
  };

  KEYS_ENUM = function(o) {
    var a, k;
    a = [];
    for (k in o) {
      a.push(k);
    }
    return a;
  };

  KEYS_ENUM_OWN = function(o) {
    return Object.keys(o);
  };

  CLR_ENUM = function(o) {
    var k;
    for (k in o) {
      delete o[k];
    }
    return o;
  };

  A_CLR_ENUM = function() {
    var j, l, ref;
    for (j = l = 0, ref = arguments.length - 1; (0 <= ref ? l <= ref : l >= ref); j = 0 <= ref ? ++l : --l) {
      CLR_ENUM(arguments[j]);
    }
  };

  CONTAINS_INSENSITIVE = function(haystack, needle) {
    return S.CONTAINS_INSENSITIVE("" + haystack, "" + needle);
  };

  DEEP_OPPOSITE = function(o) {
    var depth, l, len, p, ref, tar;
    tar = {};
    depth = 0;
    while (true) {
      ref = Object.getOwnPropertyNames(o);
      for (l = 0, len = ref.length; l < len; l++) {
        p = ref[l];
        console.log(`DEEP: ${depth} ${p} ${(p === "sql" ? " *******************" : "")}`);
        tar[p] = o[p];
      }
      if (o = Object.getPrototypeOf(o)) {
        depth++;
      } else {
        return tar;
      }
    }
  };

  DEEP = DEEP_TOO_MUCH_WORK = function(o) {
    var a, i, l, len, len1, m, o2, pn, ref, ref1, src, tar;
    a = [];
    while (true) {
      if (o2 = Object.getPrototypeOf(o)) {
        a.push(o);
        o = o2;
      } else {
        tar = {};
        ref = a.reverse();
        for (i = l = 0, len = ref.length; l < len; i = ++l) {
          src = ref[i];
          ref1 = Object.getOwnPropertyNames(src);
          //				console.log "object #{i}"
          for (m = 0, len1 = ref1.length; m < len1; m++) {
            pn = ref1[m];
            //					console.log "DEEP: #{pn} #{if pn is "sql" then " *******************" else ""}"
            tar[pn] = src[pn];
          }
        }
        return tar;
      }
    }
  };

  DEEP_DNW = function(o) {
    var k, tar, v;
    tar = {};
    for (k in o) {
      v = o[k];
      tar[k] = v;
    }
    return tar;
  };

  DFS_BREAKABLE = function(o, fn) { //REC
    var DFS_, bContinue;
    bContinue = true;
    DFS_ = function(o, depth) {
      var dt, idx, k, l, len, v;
      for (k in o) {
        v = o[k];
        switch (dt = IS.dt(v)) {
          case "a":
            if (!(bContinue = fn(o, k, v, dt, depth))) {
              return false;
            }
            for (idx = l = 0, len = v.length; l < len; idx = ++l) {
              V = v[idx];
              dt = IS.dt(v);
              if (!(bContinue = fn(v, idx, V, dt, depth))) {
                return false;
              }
              if (dt === "o") {
                if (!(bContinue = DFS_(V, depth + 1))) {
                  return false;
                }
              }
            }
            return;
          case "o":
            if (!(bContinue = fn(o, k, v, dt, depth))) {
              return false;
            }
            if (!(bContinue = DFS_(v, depth + 1))) {
              return false;
            }
            break;
          default:
            if (!(bContinue = fn(o, k, v, dt, depth))) {
              return false;
            }
        }
      }
      return true;
    };
    return DFS_(o, 0);
  };

  //USAGE: O.LOG_DRILL @owner, grep:"send",bValues:true
  LOG_DRILL = function(o, opts = {}) {
    var afterMsg, depth, grep, grepUC, l, len, p, ref;
    afterMsg = "";
    if (opts.grep) {
      grepUC = opts.grep.toUpperCase();
      afterMsg = `GREP "${opts.grep}"`;
    }
    grep = function(s) {
      var ex, test;
      if (opts.grep) {
        try {
          test = "" + s;
        } catch (error) {
          ex = error;
          test = "";
          console.log(`grep: ex=${ex}`);
        }
        if (test.toUpperCase().includes(grepUC)) {
          return true;
        } else {
          return false;
        }
      } else {
        return true;
      }
    };
    depth = 0;
    while (true) {
      console.log(`${" ".repeat(depth * 8)}${`${depth}`.repeat(30)} ${afterMsg}`);
      ref = Object.getOwnPropertyNames(o).sort();
      for (l = 0, len = ref.length; l < len; l++) {
        p = ref[l];
        if (grep(p) || grep(o[p])) {
          if (opts.bValues) {
            console.log(`${" ".repeat(depth * 8)}[${depth}] ${V.KV(p, o[p], true)}`);
          } else {
            console.log(`${" ".repeat(depth * 8)}[${depth}] ${V.PAIR(p, o[p])}`);
          }
        }
      }
      //			LOG Object.getOwnPropertyDescriptor o, p
      if (o = Object.getPrototypeOf(o)) {
        depth++;
      } else {
        return;
      }
    }
  };

  duck = function(o) {
    if (o) {
      if (typeof o === "object") {
        //			console.log "*********** #{o instanceof Object}"
        if (o instanceof Object) {
          switch (false) {
            case !o.hasOwnProperty("__cn"):
              return "Flexbase object";
            case !o.hasOwnProperty("__CLASS_NAME"):
              return o.__CLASS_NAME;
            default:
              return "OBJ";
          }
        } else {
          return "NAKED_OBJ";
        }
      } else if (typeof o === "function") {
        return "FN";
      } else {
        return o;
      }
    } else {
      return "n-u-l-l";
    }
  };

  //MOVE
  SUMMARY = function(o) {
    var CEW, _, _c, _e, _w, allObjCnt, allPropCnt, allSizeApprox, drill, ex, highWaterMark, kill, stack, times;
    kill = null;
    try {
      _c = _e = _w = 0;
      highWaterMark = 0;
      allPropCnt = 0; // may be off by 1
      allObjCnt = 0;
      allSizeApprox = 0;
      stack = [];
      times = 0;
      drill = function(o, depth) {
        var a, d, i, j, l, len, m, p, q, ref, ref1, ref2, type;
        if (kill != null) {

        } else if (o != null) {
          type = Object.prototype.toString.call(o);
          //				console.log "depth=#{depth} type=#{type}"	# #{JSON.stringify o}
          switch (type) {
            case '[object Object]':
              allObjCnt++;
              allSizeApprox += 4; //GUESS
              if (depth > highWaterMark) {
                highWaterMark = depth;
              }
              a = Object.getOwnPropertyNames(o);
              for (l = 0, len = a.length; l < len; l++) {
                p = a[l];
                d = Object.getOwnPropertyDescriptor(o, p);
                if (d.configurable) {
                  _c++;
                }
                if (d.enumerable) {
                  _e++;
                }
                if (d.writable) {
                  _w++;
                }
                allPropCnt++;
                stack.push(p);
                if (stack.length > 3) {
//								console.log "stack: #{stack.join "/"}"
                  for (i = m = 0, ref = stack.length - 3; (0 <= ref ? m <= ref : m >= ref); i = 0 <= ref ? ++m : --m) {
//									console.log "i=#{i}"
                    for (j = q = ref1 = i + 2, ref2 = stack.length - 3; (ref1 <= ref2 ? q <= ref2 : q >= ref2); j = ref1 <= ref2 ? ++q : --q) {
                      //										console.log "  j=#{j}   #{stack[i]}=#{stack[j]}   ...  #{stack[i+1]}=#{stack[j+1]}"
                      if (i !== j && stack[i] === stack[j] && stack[i + 1] === stack[j + 1]) {
                        //											console.log "CYCLICAL at #{i} and #{j}"
                        //											console.log "stack: #{stack.join "/"}"
                        //											process.exit 1
                        kill = `CYCLICAL at ${i} and ${j}: ${stack.join(',')}`;
                        return;
                      }
                    }
                  }
                }
                //							if times++ > 20
                //								process.exit 1
                drill(o[p], depth + 1);
                stack.pop();
              }
              break;
            case '[object String]':
              return allSizeApprox += o.length;
            default:
              return allSizeApprox += 4;
          }
        }
      };
      drill(o, 0);
      //		console.log "kill=#{kill}"
      CEW = `CEW(${_c},${_e},${_w})`;
      highWaterMark++;
      switch (allObjCnt) {
        case 0:
          return "NULL";
        case 1:
          return `${duck(o)}: ${CEW} bytes=${allSizeApprox}`;
        default:
          _ = `${duck(o)}: props=${CNT_OWN(o)} ///// `;
          if (kill) {
            //					console.log "killed"
            return _ + kill;
          } else {
            //					console.log "not killed"
            return _ + `ALL: objs=${allObjCnt} ${CEW} bytes=${allSizeApprox} depth=${highWaterMark}`;
          }
      }
    } catch (error) {
      ex = error;
      return console.log(`CATCH: ${ex}`);
    }
  };

  DUMP = function(o, opts = {
      maxDepth: 5
    }) {
    var DEBUG, dump, map, ref, stack;
    DEBUG = 0;
    if (DEBUG) {
      V.LOG_MULTI(o);
    }
    stack = [];
    map = {};
    dump = function(pn, v, depth, bChecking = true) {
      var a, arg, cnt, ex, i, indent, item, j, kill, l, len, len1, len2, len3, m, n, q, r, ref, ref1, ref2, results, results1, results2, t, type, u;
      //		console.log "dump: depth=#{depth} #{JSON.stringify v}"
      type = Object.prototype.toString.call(v);
      //		console.log "DEBUG: #{pn}=#{v} ARRAY=#{Array.isArray v} TYPEOF=#{typeof v} TYPE2=#{type} JSON=#{JSON.stringify v}"
      //		V.LOG_SINGLE v, pn

      //TODO: pass pn as parameter
      indent = function(s) {
        return console.log(`>  ${" ".repeat(depth * 8)}${(depth > 0 ? " âˆŸ " : "")}${(pn.length > 0 ? `${pn}:` : "")} ${s}`);
      };
      if (Array.isArray(v)) {
        if (v.length === 0) {
          return indent("[]");
        } else {
          indent(`ARRAY (len=${v.length}):`);
          results = [];
          for (n = l = 0, len = v.length; l < len; n = ++l) {
            item = v[n];
            results.push(dump(`${(pn.length > 0 && pn[0] !== '[' ? "" : "")}[${n}]`, item, depth + 1, false));
          }
          return results;
        }
      } else if (v instanceof Error) {
        indent("details:");
        a = Object.getOwnPropertyNames(v);
        results1 = [];
        for (m = 0, len1 = a.length; m < len1; m++) {
          pn = a[m];
          results1.push(dump(pn, v[pn], depth + 1));
        }
        return results1;
      } else if (v instanceof Uint8Array) {
        //			console.log "111 #########################################"
        return indent(V.DUMP(v));
      } else if (type === '[object Arguments]') {
        indent(`found arguments (length=${v.length})`);
        results2 = [];
        for (i = q = 0, len2 = v.length; q < len2; i = ++q) {
          arg = v[i];
          //				indent "arguments[#{i}] = #{arg}"

          //				indent "arguments[#{i}] ===================="
          //				LOG arg
          results2.push(dump(`arguments[${i}]`, arg, depth + 1));
        }
        return results2;
      } else if (type === '[object Object]') {
        //			console.log "object depth=#{depth}"
        kill = null;
        stack.push(pn);
        if (stack.length > 3) {
//				console.log "stack: #{stack.join "/"}"
          for (i = r = 0, ref = stack.length - 3; (0 <= ref ? r <= ref : r >= ref); i = 0 <= ref ? ++r : --r) {
//					console.log "i=#{i}"
            for (j = t = ref1 = i + 2, ref2 = stack.length - 3; (ref1 <= ref2 ? t <= ref2 : t >= ref2); j = ref1 <= ref2 ? ++t : --t) {
              //						console.log "  j=#{j}   #{stack[i]}=#{stack[j]}   ...  #{stack[i+1]}=#{stack[j+1]}"
              if (i !== j && stack[i] === stack[j] && stack[i + 1] === stack[j + 1]) {
                //							console.log "CYCLICAL at #{i} and #{j}"
                //							console.log "stack: #{stack.join "/"}"
                //							process.exit 1
                kill = `CYCLICAL at ${i} and ${j}: ${stack.join(',')}`;
                kill = "CYCLICAL";
              }
            }
          }
        }
        if (cnt = CNT_OWN(v)) {
          //				console.log "xxx=#{depth}"
          if (depth === opts.maxDepth) {
            //					indent "#{duck v} (#{cnt}) at max"
            indent(`${SUMMARY(v)} *** TOO DEEP`);
          } else {
            try {
              //					indent "*** TOO DEEP"
              indent(`${duck(v)} (${cnt})`);
            } catch (error) {
              ex = error;
              indent(`duck exception (${cnt}): ex=${ex}`);
            }
            //				for pn of v
            //					console.log "of: pn=#{pn}"

            //				#NOTE: "including non-enumerable properties except for those which use Symbol"
            //				for pn in Object.getOwnPropertyNames v
            //					console.log "Object.getOwnPropertyNames: pn=#{pn}"

            //TODO: identify non-enumerable properties just because!
            a = Object.keys(v);
            a.sort();
//				indent "SORTED: #{a.join ","}"
            for (u = 0, len3 = a.length; u < len3; u++) {
              pn = a[u];
              if (g_LOGIgnore[pn]) {
                dump(pn, "**LogIgnore**", depth + 1);
              } else {
                if (!kill) {
                  if (map[pn] != null) {
                    if (++map[pn] === 10) {
                      //								indent "########## property: depth=#{depth} '#{pn}' has occurred too many times.  Stopped at #{MAX_PROPERTY_DEPTH}.  Circular structure?"
                      kill = `########## '${pn}' recursive`;
                    }
                  } else {
                    map[pn] = 1;
                  }
                }
                if (kill) {
                  //								indent "#{kill}: #{pn}"
                  indent(`${kill}`);
                } else {
                  dump(pn, v[pn], depth + 1);
                }
              }
            }
          }
        } else {
          indent("OBJ EMPTY");
        }
        return stack.pop();
      } else {
        return indent(V.DUMP(v));
      }
    };
    if (arguments.length === 0) {
      return console.log("WARNING: DUMP wasn't passed anything");
    } else if ((ref = arguments.length) === 1 || ref === 2) {
      return dump("", o, 0);
    } else {
      throw new Error("passed too many arguments!");
    }
  };

  IS_EMPTY = function(o) {
    return Object.keys(o).length === 0 && o.constructor === Object;
  };

  //TODO: flag 'undefined' unless opt set
  //SELF-CONTAINED
  LOG = function(o) {
    var DEBUG, Q, i, l, len, len1, m, v;
    //	throw new Error "O.LOG!!!!!!!!!!!!!!!!!"
    DEBUG = 0;
    if (DEBUG) {
      V.LOG_MULTI(o);
    }
    Q = ">  ";
    if (arguments.length === 0) {
      console.log("WARNING: LOG wasn't passed anything");
    } else if (arguments.length === 1) {
      DUMP(o, {
        maxDepth: 5
      });
    } else {
      if (true) {
        for (i = l = 0, len = arguments.length; l < len; i = ++l) {
          v = arguments[i];
          if (v == null) {
            console.log(`${Q}LOGARG[${i}]: UNDEFINED`);
          } else if (Object.prototype.toString.call(v) === '[object String]') {
            //				console.log "#{v}"	# echo plain strings out directly as we find them
            console.log(`${Q}LOGARG[${i}]: ${V.DUMP(v)}`);
          } else {
            console.log(`LOGARG[${i}]:`, v, 0);
          }
        }
      } else {
//TODO: put on a same line
        for (i = m = 0, len1 = arguments.length; m < len1; i = ++m) {
          v = arguments[i];
          if (v == null) {
            console.log(`${Q}LOGARG[${i}]: UNDEFINED`);
          } else if (Object.prototype.toString.call(v) === '[object String]') {
            //				console.log "#{v}"	# echo plain strings out directly as we find them
            console.log(`${Q}LOGARG[${i}]: ${V.DUMP(v)}`);
          } else {
            console.log(`LOGARG[${i}]:`, v, 0);
          }
        }
      }
    }
    if (DEBUG) {
      console.log("\n\n\n\n\n\n\n\n\n\n");
    }
  };

  module.exports = {
    AllMethodsCSL: function(object) {
      var a, pn;
      a = [];
      for (pn in object) {
        a.push(pn);
      }
      return a.sort().join(",");
    },
    //	CLR_ENUM:CLR_ENUM
    //	A_CLR_ENUM:A_CLR_ENUM
    //	CONTAINS_INSENSITIVE:CONTAINS_INSENSITIVE
    //	DFS_BREAKABLE: DFS_BREAKABLE
    //	DELTA: (o0, o1) ->
    //		for k of o1
    //			delete o0[k]
    //		o0
    //	DIFF: (a, b) ->												# a-b
    //		o = Object.create null
    //		for pn in KEYS a
    //			o[pn] = b[pn] if pn !of b
    //		o
    EQUALS: function(o0, o1) {
      var compareTwo, leftChain, rightChain;
      leftChain = rightChain = null; //CLOSURE
      return compareTwo = function(o0, o1) {
        // remember that NaN===NaN returns false and isNaN(undefined) returns true
        //GETTING: 0x800a1389 - Microsoft JScript runtime error: Number expected
        //if !(o0 instanceof Object and o1 instanceof Object)
        if (Object.prototype.toString.call(o0) === "[object Object]" && Object.prototype.toString.call(o1) === "[object Object]") {
          if (Object.keys(o0).length === 0 && Object.keys(o1).length === 0) {
            return true;
          }
        } else {
          if (isNaN(o0) && isNaN(o1) && typeof o0 === 'number' && typeof o1 === 'number') {
            return true;
          }
        }
        if (o0 === o1) {
          // compare primitives and functions
          // check if both arguments reference the same object
          // especially useful on step when comparing prototypes
          return true;
        }
        if (o0 && !o1 || !o0 && o1) {
          //IMPROVED: seems like "no brainer???"
          return false;
        }
      };
    },
    // works in case when functions are created in constructor
    // comparing dates is a common scenario. Another built-ins?
    // we can even handle functions passed across iframes
    // precedence: instanceOf then && then ||
    //			if typeof o0 is 'function' and typeof o1 is 'function'									or
    //				o0 instanceof Date		and	o1 instanceof Date										or
    //				o0 instanceof RegExp	and	o1 instanceof RegExp									or
    //				o0 instanceof String	and	o1 instanceof String									r
    //				o0 instanceof Number	and	o1 instanceof Number
    //return o0.toString() is o1.toString()
    //return o0.toString().replace /~/g, "|"  is o1.toString().replace / /g, ""
    //				return o0.toString().replace(/\ /g, "") is o1.toString().replace /\ /g, ""

    //			#IMPROVED: seems like "no brainer???"
    //			return false if Object.keys(o0).length isnt Object.keys(o1).length

    //			# check for infinitive linking loops
    //			return false if leftChain.indexOf(o0) >= 0 || rightChain.indexOf(o1) >= 0
    //#
    //			# quick checking of one object being a subset of another
    //			#OPTIM: cache the structure of arguments[0]
    //			for k of o1
    //#return false if o1.hasOwnProperty(k) isnt o0.hasOwnProperty(k)
    //				return false if Object::hasOwnProperty.call(o0, k) isnt Object::hasOwnProperty.call(o1, k)
    //				return false if typeof o1[k] isnt typeof o0[k]

    //			for k of o0
    //#return false if o1.hasOwnProperty(k) isnt o0.hasOwnProperty(k)
    //				return false if Object::hasOwnProperty.call(o0, k) isnt Object::hasOwnProperty.call(o1, k)
    //				return false if typeof o1[k] isnt typeof o0[k]

    //				switch typeof o0[k]
    //					when 'object', 'function'
    //#CASE: NON-PRIMITIVE
    //						leftChain.push o0
    //						rightChain.push o1

    //						return false if !compareTwo o0[k], o1[k]

    //						leftChain.pop()
    //						rightChain.pop()
    //					else
    //#CASE: PRIMITIVE
    //						return false if o0[k] isnt o1[k]

    //			# at last checking prototypes as good as we can
    //			#home grown objects don't neccessary inherit from Object: return false if !(o0 instanceof Object && o1 instanceof Object)
    //			#return false if o0.isPrototypeOf(o1) || o1.isPrototypeOf(o0)
    //			return false if Object::isPrototypeOf.call(o0, o1) || Object::isPrototypeOf.call(o1, o0)
    //			return false if o0.constructor isnt o1.constructor
    //			return false if o0.prototype isnt o1.prototype

    //			true												#END: compareTwo

    //		for j in [1..arguments.length-1]
    //			leftChain = []
    //			rightChain = []

    //			return false if !compareTwo arguments[0], arguments[j]

    //		true#/EQUALS
    //	EQUALS_OBJECTS_THAT_ARE_CHAINED_TO_OBJECT_PROTOTYPE: (o0, o1) ->#NOT-USED
    //		leftChain=rightChain=null								#CLOSURE

    //		compareTwo = (o0, o1) ->
    //# remember that NaN===NaN returns false and isNaN(undefined) returns true
    //			return true if isNaN(o0) && isNaN(o1) && typeof o0 is 'number' && typeof o1 is 'number'

    //			# compare primitives and functions
    //			# check if both arguments reference the same object
    //			# especially useful on step when comparing prototypes
    //			return true if o0 is o1

    //			#IMPROVED: seems like "no brainer???"
    //			return false if o0 and !o1 or !o0 and o1

    //			# works in case when functions are created in constructor
    //			# comparing dates is a common scenario. Another built-ins?
    //			# we can even handle functions passed across iframes
    //			# precedence: instanceOf then && then ||
    //			if	typeof o0 is 'function'	&&	typeof o1 is 'function'									||
    //				o0 instanceof Date		&&	o1 instanceof Date										||
    //				o0 instanceof RegExp	&&	o1 instanceof RegExp									||
    //				o0 instanceof String	&&	o1 instanceof String									||
    //				o0 instanceof Number	&&	o1 instanceof Number
    //#return o0.toString() is o1.toString()
    //#return o0.toString().replace /~/g, "|"  is o1.toString().replace / /g, ""
    //				return o0.toString().replace(/\ /g, "") is o1.toString().replace /\ /g, ""

    //			# at last checking prototypes as good as we can
    //			return false if !(o0 instanceof Object && o1 instanceof Object)
    //			return false if o0.isPrototypeOf(o1) || o1.isPrototypeOf(o0)
    //			return false if o0.constructor isnt o1.constructor
    //			return false if o0.prototype isnt o1.prototype

    //			#IMPROVED: seems like "no brainer???"
    //			return false if Object.keys(o0).length isnt Object.keys(o1).length

    //			# check for infinitive linking loops
    //			return false if leftChain.indexOf(o0) >= 0 || rightChain.indexOf(o1) >= 0

    //			# quick checking of one object being a subset of another
    //			#OPTIM: cache the structure of arguments[0]
    //			for k of o1
    //				return false if o1.hasOwnProperty(k) isnt o0.hasOwnProperty(k)
    //				return false if typeof o1[k] isnt typeof o0[k]

    //			for k of o0
    //				return false if o1.hasOwnProperty(k) isnt o0.hasOwnProperty(k)
    //				return false if typeof o1[k] isnt typeof o0[k]

    //				switch typeof o0[k]
    //					when 'object', 'function'
    //#CASE: NON-PRIMITIVE
    //						leftChain.push o0
    //						rightChain.push o1

    //						return false if !compareTwo o0[k], o1[k]

    //						leftChain.pop()
    //						rightChain.pop()
    //					else
    //#CASE: PRIMITIVE
    //						return false if o0[k] isnt o1[k]

    //			true												#END: compareTwo

    //		for j in [1..arguments.length-1]
    //			leftChain = []
    //			rightChain = []

    //			return false if !compareTwo arguments[0], arguments[j]

    //		true#/EQUALS_OBJECTS_THAT_ARE_CHAINED_TO_OBJECT_PROTOTYPE
    //	I: (o) ->
    //		if typeof o is "number"
    //			o
    //		else
    //			parseInt o, 10
    //	IS_EMPTY: (o) ->
    //		for k of @KEYS o
    //			return false
    //		true

    CNT: CNT,
    CNT_OWN: CNT_OWN,
    CNT_ENUM: CNT_ENUM,
    CNT_ENUM_OWN: CNT_ENUM_OWN,
    DEEP: DEEP,
    duck: duck,
    DUMP: DUMP,
    LOG_DRILL: LOG_DRILL,
    INTERSECTS_ENUM: function(o0, o1) {
      var k;
      for (k in o0) {
        if (k in o1) {
          return true;
        }
      }
      return false;
    },
    IS_EMPTY: IS_EMPTY,
    KEYS: KEYS,
    KEYS_OWN: KEYS_OWN,
    KEYS_ENUM: KEYS_ENUM,
    KEYS_ENUM_OWN: KEYS_ENUM_OWN,
    LOG: LOG,
    LOGIgnore: g_LOGIgnore,
    SUMMARY: SUMMARY,
    //	N: (o) ->
    //		if typeof o is "number"
    //			o
    //		else if R.RE.TEST_PLUS_MINUS_FLOAT.test o
    //			parseFloat o, 10
    //		else
    //			throw o
    //	SUB_SUP_PROP_VALUES_EQUALS: (sub, sup) ->
    //		for k of sub
    //			return false unless sup[k]?
    //			return false unless R.O.EQUALS sub[k], sup[k]
    //		true

    //if ut
    s_ut: function() {
      var O_UT, UT;
      UT = require('./ut');
      return (new (O_UT = class O_UT extends UT {
        run() {
          this.s("DUMP", function() {
            var fn;
            fn = (o, opts) => {
              if (trace.HUMAN) {
                //							@log "IN:  #{JSON.stringify o}", o
                this.log("IN:  ", o);
                this.log('-'.repeat(40));
                DUMP(o, opts);
                return this.log('='.repeat(150));
              }
            };
            this.t("simple", function() {
              return fn({
                top: 55,
                second: {
                  atSecond: true
                }
              });
            });
            return this.t("maxDepth", function() {
              return fn({
                top: 55,
                second: {
                  atSecond: true
                }
              }, {
                maxDepth: 1
              });
            });
          });
          this.s("LOG", function(ut) {
            this.t("simple", function(ut) {
              var o, p;
              if (trace.HUMAN) {
                LOG(null);
                LOG(3.1415926);
                LOG({
                  a: "a"
                });
                LOG(["a", "b"]);
                LOG([[[["a", "b"], "c"], "b"], "c"]);
                o = {};
                o.z = "some value";
                o.a = "some value";
                o.q = "some value";
                o.k = "some value";
                o.r = "some value";
                for (p in o) {
                  this.log(`p=${p}`);
                }
                return LOG(o);
              }
            });
            this.t("multiple parameters", function(ut) {
              if (trace.HUMAN) {
                LOG("peter", "charles", "alvin");
                return LOG({
                  "a": "peter"
                }, {
                  "b": "charles"
                }, {
                  "c": "alvin"
                });
              }
            });
            return this.s("LOG_DRILL", function() {
              //PATTERN: ancestor function called by children
              return this.create = function() {
                var o1, o2, o3;
                o1 = {
                  a: "aaa"
                };
                o2 = Object.create(o1);
                o2.b = "bbb";
                o3 = Object.create(o2);
                o3.c = "ccc";
                o3;
                this.t("trivial3", function() {
                  if (trace.HUMAN) {
                    return LOG_DRILL(this.create());
                  }
                });
                this.t("values", function() {
                  if (trace.HUMAN) {
                    return LOG_DRILL(this.create(), {
                      bValues: true
                    });
                  }
                });
                return this.t("grep", function() {
                  if (trace.HUMAN) {
                    return LOG_DRILL(this.create(), {
                      bValues: true,
                      grep: "to"
                    });
                  }
                });
              };
            });
          });
          return this.s("SUMMARY", function() {
            var fn;
            fn = (o) => {
              var s;
              s = SUMMARY(o);
              if (trace.HUMAN) {
                //							@log "IN:  #{JSON.stringify o}", o
                this.log("IN:  ", o);
                this.log(`OUT: ${s}`);
                return this.log('='.repeat(150));
              }
            };
            this.t("CEW", function() {
              var c, e, l, len, len1, len2, m, o, pn, q, ref, ref1, ref2, w;
              o = {};
              ref = [false, true];
              for (l = 0, len = ref.length; l < len; l++) {
                c = ref[l];
                ref1 = [false, true];
                for (m = 0, len1 = ref1.length; m < len1; m++) {
                  e = ref1[m];
                  ref2 = [false, true];
                  for (q = 0, len2 = ref2.length; q < len2; q++) {
                    w = ref2[q];
                    pn = `${(c ? 'C' : '_')}${(e ? 'E' : '_')}${(w ? 'W' : '_')}`;
                    Object.defineProperty(o, pn, {
                      configurable: c,
                      enumerable: e,
                      value: pn,
                      writable: w
                    });
                  }
                }
              }
              return fn(o);
            });
            this.t("simple", function() {
              return fn({
                top: 55,
                second: {
                  atSecond: true
                }
              });
            });
            return this.t("cyclical", function() {
              var o1, o2;
              o1 = {
                a: "a"
              };
              o2 = {
                b: "b",
                o1: o1
              };
              o1.o2 = o2;
              return fn(o1);
            });
          });
        }

      })).run();
    }
  };

  //endif

}).call(this);
