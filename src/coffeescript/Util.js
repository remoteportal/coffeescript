// Generated by CoffeeScript 2.4.1
(function() {
  //if node
  var MMSS, N, NODE_util, O, RE_ISOLATE_TYPE, abort, exitAfterSlightDelay__soThatLogCanFinishWriting, fileDownload, fs, fs_directoryDeleteRecursive, fs_directoryEnsure, latestGet, logBase, m_logEmptyNextCharacter, m_logStream, pickRnd, rnd, size_pr, type;

  fs = require('fs');

  NODE_util = require('util');

  //elseif rn
  //import Expo, { FileSystem } from 'expo'
  //endif
  N = require('./N');

  O = require('./O');

  //trace = require './trace'
  m_logStream = null;

  m_logEmptyNextCharacter = 'A';

  //TODO: log multiple objects before options

  //H: try to move these into concrete S, N, O, etc., files???

  //DUP
  RE_ISOLATE_TYPE = /\[object ([^\]]*)\]/;

  //DUP
  type = function(v) {
    var match, t;
    // 	primative vs. non-primative types
    if (typeof v === "object") {
      t = Object.prototype.toString.call(v);
      match = RE_ISOLATE_TYPE.exec(t);
      if (match && match.length >= 2) {
        //			console.log "match=#{match[1]}"
        t = match[1].toLowerCase();
      } else {
        //			console.log "#{v} => #{t} (call)"
        util.abort(`V.type: Unable to isolate type substring from: "${t}"`);
      }
    } else {
      t = typeof v;
    }
    //		console.log "#{v} => #{t} (typeof)"
    return t;
  };

  abort = function(msg) {
    m_logStream = null; //RECENT2
    
    //if node
    console.error("#".repeat(60));
    if (msg) {
      console.error(`NODE ABORTED${(msg ? `: ${msg}` : "")}`);
    } else {
      console.error("ABORTING NOW!!! (log will be truncated...)");
    }
    console.error("#".repeat(60));
    //	process.exit 1
    throw new Error("util.abort() called!");
  };

  //else
  //		throw "ABOPT!!!!!!!!!!!!!!!!!!"
  //endif
  exitAfterSlightDelay__soThatLogCanFinishWriting = function(ms = 500) {
    console.error("***************************** exitAfterSlightDelay__soThatLogCanFinishWriting PRE");
    process.exit(1); // T
    return setTimeout(() => {
      console.error("***************************** exitAfterSlightDelay__soThatLogCanFinishWriting POST");
      return process.exit(1);
    }, ms);
  };

  fileDownload = function(URL, path) {
    var log, logCatch;
    log = function(s, v) {
      return logBase("fileDownload", s, v);
    };
    logCatch = function(ex) {
      return logBase("fileDownload", "CATCH", ex);
    };
    return new Promise((resolve, reject) => {
      var ex, file, request, sendReq;
      try {
        //			log "#{URL} => #{path}"
        fs = require('fs');
        request = require('request');
        file = fs.createWriteStream(path);
        file.on('finish', function() {
          //				log "finished"
          return file.close(() => {
            //					log "closed"
            return resolve(path);
          });
        });
        file.on('error', function(err) {
          //				log "file on error", err
          fs.unlink(path); //ASYNC: but don't wait
          return reject(err);
        });
        //			log "file", file
        sendReq = request.get(URL);
        sendReq.on('response', function(response) {
          //				log "on response", response
          //				log "response.statusCode=#{response.statusCode}"
          if (response.statusCode !== 200) {
            return reject(new Error(`response: statusCode=${response.statusCode}`));
          }
        });
        sendReq.on('error', function(err) {
          log("request on error", err);
          fs.unlink(path); //ASYNCH	#UNNECCESSARY: @util.promisify(fs.unlink) path
          return reject(err);
        });
        return sendReq.pipe(file);
      } catch (error) {
        //			log "sendReq", sendReq
        ex = error;
        console.log("catch");
        logCatch(ex);
        return reject(ex);
      }
    });
  };

  fs_directoryEnsure = function(directory, cb) {
    //		console.log "fs_directoryEnsure: #{directory}"
    return fs.access(directory, fs.constants.W_OK, (err) => {
      if (err) {
        if (err.code === "ENOENT") {
          //					@log "mkdir: #{directory}"
          return fs.mkdir(directory, (err) => {
            if (err) {
              //							@logError "mkdir", err
              return cb(err);
            } else {
              return cb();
            }
          });
        } else {
          //					@logError "access", err
          O.LOG(err);
          return cb(err);
        }
      } else {
        //				@log "already exists"
        return cb();
      }
    });
  };

  fs_directoryDeleteRecursive = function(directory) {
    //	console.log "fs_directoryDeleteRecursive: #{directory}"
    if (fs.existsSync(directory)) {
      fs.readdirSync(directory).forEach(function(file, index) {
        var curPath;
        curPath = directory + '/' + file;
        if (fs.lstatSync(curPath).isDirectory()) {
          return fs_directoryDeleteRecursive(curPath);
        } else {
          //				console.log "fs_directoryDeleteRecursive: unlink: #{curPath}"
          return fs.unlinkSync(curPath);
        }
      });
      return fs.rmdirSync(directory);
    }
  };

  // usage:
  // fnn, s, v, bDeep
  // fnn, s, v0, v1, ..., vN		where any v can be opts object
  logBase = function(fnn, s, v, optionsObjectOrO_LOG_flag) { //H #MESS
    var V, a, bFoundOpts, ex, extra, i, j, k, len, len1, line, opt, opts, pn, pv, ref, ref1, ref2, vPart;
    //	console.log "logBase"
    //	O.LOG arguments
    //	abort()
    opts = {
      bVisible: true,
      bDeep: true
    };
    //	a = arguments.slice()
    // copy array
    a = Array.prototype.slice.call(arguments, 1);
    //HELPFUL #DEBUGGING
    //	O.LOG a
    //	abort()
    if (type(a[0]) !== "string") {
      //		console.log "1111111111 #{type a[0]} (#{type(a[0]) isnt "string"}) 1111111111 #{JSON.stringify a}"
      a.unshift("");
      //		console.log "2222222222 #{JSON.stringify a}"
      optionsObjectOrO_LOG_flag = v;
      v = s;
      s = "";
    }
    // ARGUMENTS SHIFT LEFT!
    // now:
    //	0	1	2
    //	s, v, opt
    //	O.LOG a
    if (a.length === 3 && typeof optionsObjectOrO_LOG_flag === "boolean") {
      opts.bDeep = optionsObjectOrO_LOG_flag;
      //		console.log "boolean passed as third argument: bDeep=#{opts.bDeep}"
      a.splice(2, 1);
    }
    //		O.LOG a
    //		console.log "len=#{a.length}"
    //	abort()
    if (a.length > 2) {
      ref = [0, a.length - 1];
      //		console.log "look for options object"
      //		O.LOG a
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        //			O.LOG a[i]
        if (typeof a[i] === "object") {
          bFoundOpts = false;
          ref1 = ["bDeep", "bVisible"];
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            opt = ref1[k];
            if (opt in a[i]) {
              ref2 = a[i];
              // override specific opts
              for (pn in ref2) {
                pv = ref2[pn];
                //							console.log "opt: override: #{pn}=#{a[i][pn]}"
                opts[pn] = a[i][pn];
              }
            }
          }
        }
      }
    }
    //	console.log "FUCKING MESS"
    vPart = "";
    extra = "";
    try {
      if (v != null) {
        //			console.log "v?"
        //			O.LOG v
        //			if v instanceof String
        //				extra = ""
        if (v instanceof Error) {
          if (!opts.bDeep) {
            extra = `: ${v.stack}`;
          }
        } else if (typeof v === "object") {
          if (!opts.bDeep) {
            extra = ` ${JSON.stringify(v)}`;
          }
        } else {
          V = require('./V');
          extra = " " + V.NOT_STRING(v);
        }
      } else if (a.length > 1) {
        //			console.log "**************************"
        extra = " NULL"; //: a.length=#{a.length}"		#HELP #NEEDS-LOVE
      }
    } catch (error) {
      //			O.LOG a
      ex = error;
      extra = `: LOG_BASE INTERNAL EXCEPTION: ${ex}`;
    }
    if (!s && arguments.length === 1) {
      //		console.log "****fff****"
      //		O.LOG arguments
      //		throw new Error "FATAL"
      a.push(extra = m_logEmptyNextCharacter.repeat(60));
      m_logEmptyNextCharacter = String.fromCharCode(m_logEmptyNextCharacter.charCodeAt(0) + 1);
      s = "";
    }
    if ((s != null ? s.length : void 0) > 1 && s[0] === '^') {
      // omit header for strings that start with ^
      line = `${s.slice(1)}${extra}`;
    } else {
      line = `${MMSS()} [${fnn}] ${s}${extra}`;
    }
    //	console.log "VVVVVVVVVVVVVVV deep=#{opts.bVisible} v=#{v}"
    if (opts.bVisible) {
      console.log(line);
      //		console.log "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
      if (opts.bDeep && v) {
        //			console.log "***************** v=#{v}"
        //			console.log "*****************"
        O.LOG(v);
      }
    }
    //		O.LOG a...
    if (line.indexOf("[_Client] object") > 0) {
      abort("&&&&&&&&&&&&&&&&&&&&&&&&&&&");
    }
    //		console.log "HELP: #{line}"
    if (m_logStream != null) {
      return m_logStream.write(`${line}\n`);
    }
  };

  latestGet = function(clo, fq) {
    var latest, version;
    version = 0;
    while (clo[`version${version + 1}`]) {
      version++;
    }
    //	logBase "util", "version=#{version}"
    if (latest = clo[`version${version}`]) {
      return latest;
    } else {
      logBase("util", `[${fq}] Can't find version`, clo, true);
      return null;
    }
  };

  MMSS = function() {
    var date;
    return `${N.ZEROPAD((date = new Date).getMinutes(), 2)}:${N.ZEROPAD(date.getSeconds(), 2)}`;
  };

  pickRnd = function(nameSpace, csl) {
    var a;
    a = csl.split(",");
    return a[rnd(0, a.length - 1)];
  };

  //DUP?	N
  rnd = function(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
  };

  //uploadAudioAsync = (uri) ->
  //	new Promise (resolve, reject) =>
  //		@log "uploadAudioAsync: uri=#{uri}"

  //		# let apiUrl = 'https://file-upload-example-backend-dkhqoilqqn.now.sh/upload'
  //		apiURL = 'http://www.skillsplanet.com:3399/upload'

  //		uriParts = uri.split '.'
  //		fileType = uriParts[uriParts.length - 1]

  //		GUID = fb.GUID();

  //		@log "uploadAudioAsync: #{GUID}.#{fileType}"

  //		formData = new FormData()
  //		formData.append 'avatar', uri,
  //			name: "#{GUID}.#{fileType}",
  //			type: "image/#{fileType}"

  //		options =
  //			method: 'POST'
  //			body: formData
  //			headers:
  //				Accept: 'application/json'
  //				'Content-Type': 'multipart/form-data'

  //		fetch(apiURL, options).then (json) =>
  //			@log "fetch success", json
  //			if json._bodyText
  //				O = JSON.parse json._bodyText
  //				@log "key=#{O.key}"
  //				#					if O.key is "key here"
  //				#						resolve "#{GUID}.#{fileType}"
  //				#					else
  //				#						reject O
  //				resolve "#{GUID}.#{fileType}"
  //			else
  //				reject "json._bodyText is empty"
  //		.catch (ex) =>
  //			@logCatch "fetch", ex
  //			reject ex
  size_pr = function(path) { //CONVENTION
    //	@util.promisify fs.stat		won't work because need to return size
    return new Promise((resolve, reject) => {
      fs = require('fs');
      return fs.stat(path, (err, stats) => {
        //			@log "err", err
        //			@log "stats", stats
        if (err) {
          return reject(err);
        } else {
          return resolve(stats.size);
        }
      });
    });
  };

  module.exports = {
    //if ut
    s_ut: function() {
      var UT, UtilUT;
      UT = require('./ut');
      return (new (UtilUT = class UtilUT extends UT {
        run() {
          this.t("rnd", function() {
            var b, i, j, ref;
            b = true;
            for (i = j = 0; j <= 99; i = ++j) {
              //						@log "rnd=#{rnd 10, 12}"
              b &= (10 <= (ref = rnd(10, 12)) && ref <= 12);
            }
            return this.assert(b);
          });
          return this.a("size_pr", function(ut) {
            return size_pr(ut.filepath('deanna.png')).then((size) => {
              this.eq(size, 26042);
              return ut.resolve();
            }).catch((ex) => {
              return ut.reject(ex);
            });
          });
        }

      })).run();
    },
    //endif
    abort: abort,
    exit: function(msg) {
      if (m_logStream != null) {
        m_logStream.end(`\n--EOF but PREMATURE EXIT: ${msg}--`);
      }
      m_logStream = null;
      //if node
      console.error("#".repeat(60));
      if (msg) {
        console.error(msg);
      } else {
        console.error("told to exit");
      }
      console.error("#".repeat(60));
      console.error("Exiting node...");
      return exitAfterSlightDelay__soThatLogCanFinishWriting();
    },
    //else
    //		console.error "#".repeat 60
    //		if msg
    //			console.error msg
    //		else
    //			console.error "EXIT NOT POSSIBLE"
    //		console.error "#".repeat 60
    //endif
    fileDownload: fileDownload,
    fs_directoryEnsure: fs_directoryEnsure,
    fs_directoryEnsurePromise: function(directory) {
      return NODE_util.promisify(fs_directoryEnsure)(directory);
    },
    fs_directoryDeleteRecursive: fs_directoryDeleteRecursive,
    latestGet: latestGet,
    logBase: logBase,
    pickRnd: pickRnd,
    rnd: rnd,
    size_pr: size_pr,
    streamSet: function(_) {
      return m_logStream = _;
    }
  };

  //	uploadAudioAsync: uploadAudioAsync

}).call(this);
