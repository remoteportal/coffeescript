// coffeescript.js: Generated by CoffeeScript GITLAB/lib 2.3.0
/*
V - String functions					*** PROJECT AGNOSTIC ***

WHAT: Node module

DESCRIPTION

FEATURES
-

NOTES
-

TODOs
- UT		#H

KNOWN BUGS:
-
*/
var C, CAP, COMPARE_REPORT, F, HAS_INSERTED_TEXT_IN_MIDDLE, HEX, IS, V, autoTable, stringifySafe, trace;

C = require('./C');

trace = require('./trace');

V = require('./V');

stringifySafe = function(o) {
  var pn, s;
  if (o !== null && typeof o === 'object') {
    s = "";
    for (pn in o) {
      s += `${pn}=\${o[pn]} `;
    }
    return s;
  } else {
    return o;
  }
};

autoTable = function(data, opts = {
    bHeader: true
  }) {
  var O, bFound, buf, cn, columnMap, ignoreMap, j, l, len1, len2, o, pass, ref, row;
  //	data = Object.assign {}, data
  if (opts.grep) {
    console.log(`filter: ${opts.grep}`);
    opts.grep = opts.grep.toUpperCase();
  }
  ignoreMap = {};
  if (opts.ignore) {
    ref = opts.ignore.split(",");
    for (j = 0, len1 = ref.length; j < len1; j++) {
      cn = ref[j];
      //			console.log cn
      ignoreMap[cn] = true;
    }
  }
  O = require('./O');
  if (Array.isArray(data)) {
    data = data.slice(0);
    columnMap = new Map();
    pass = function() {
      var _, k, l, len2, results, row, s, v;
      results = [];
      for (l = 0, len2 = data.length; l < len2; l++) {
        row = data[l];
        if (V.type(row) === "object") {
          results.push((function() {
            var results1;
            results1 = [];
            for (k in row) {
              v = row[k];
              if (v) {
                s = "" + v;
              } else {
                s = "•";
              }
              if (_ = columnMap.get(k)) {
                results1.push(columnMap.set(k, Math.max(_, s.length)));
              } else {
                results1.push(columnMap.set(k, s.length));
              }
            }
            return results1;
          })());
        } else {
          throw "NOT-IMPL";
        }
      }
      return results;
    };
    //		columnMap.forEach (v,k) =>
    //			console.log "each", "k=#{k} v=#{v}"
    pass();
    if (opts.bHeader) {
      o = {};
      columnMap.forEach((v, k) => {
        if (!ignoreMap[k]) {
          return o[k] = k.toUpperCase();
        }
      });
      data.splice(0, 0, o);
      pass(); // re-compute max column widths including new header strings
    }
    buf = "";
    for (l = 0, len2 = data.length; l < len2; l++) {
      row = data[l];
      if (opts.grep) {
        bFound = false;
        columnMap.forEach((v, k) => {
          if (("" + row[k]).toUpperCase().includes(opts.grep)) {
            return bFound = true;
          }
        });
        if (!bFound) {
          continue;
        }
      }
      buf += "\n";
      if (V.type(row) === "object") {
        columnMap.forEach((v, k) => {
          if (!ignoreMap[k]) {
            //						console.log "k=#{k}"
            return buf += (row[k] ? "" + row[k] : "•").substring(0, v).padEnd(v + 1);
          }
        });
      }
    }
    //		console.log buf
    return buf;
  } else {
    throw "autoTable: NOT-IMP";
  }
};

//	process.exit 1
CAP = function(s) {
  return `${s[0].toUpperCase()}${(s.length > 1 ? s.slice(1).toLowerCase() : "")}`;
};

HAS_INSERTED_TEXT_IN_MIDDLE = function(a, b) {
  "don't care";
  return false;
};

//EASY
//COOL: optionsMap for detailLevel: 1) enum, 2) one-liner, or 3) multi-line-full-report
COMPARE_REPORT = function(s1, s2, options = {}) { //H: string-oriented or value (V)-oriented?
  var _, bStrings, buf, endsDifferReport, h, j, l, len1, len2, ref, ref1, s;
  //EASY O.VALIDATE_OBJECT to make sure "preamble" is a valid option!
  buf = '';
  endsDifferReport = function(s1, s2) {
    var _, i, j, ref;
    if (s1.length > 0 && s2.length > 0) {
      i = 0;
      for (i = j = 0, ref = s1.length - 1; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {
        if (s1[i] !== s2[i]) {
          break;
        }
      }
      if (i === 0) {
        return null;
      } else {
        _ = `---------------------IDENTICAL PORTION (UP TO INDEX [${i - 1}])----------------------\n`;
        _ += `${s1.slice(0, +(i - 1) + 1 || 9e9)}\n`;
        _ += "---------------------DIFFERENT ENDINGS----------------------\n";
        _ += `${s1.slice(i)} (${s1.slice(i).length})\n\n`;
        _ += `${s2.slice(i)} (${s2.slice(i).length})`;
        return _;
      }
    } else {
      throw new Error("endsDifferReport: one string is empty");
    }
  };
  if (s1 === s2) {
    buf = "strings are the same"; //HACK: cannot I not say more?
  } else {
    bStrings = true;
    ref = [s1, s2];
    for (j = 0, len1 = ref.length; j < len1; j++) {
      s = ref[j];
      if (!IS(s)) {
        bStrings = false;
      }
    }
    if (bStrings) {
      if (options.preamble != null) {
        buf += "---------------------PREAMBLE------------------\n";
        buf += options.preamble + '\n';
      }
      buf += "---------------------LEN------------------\n";
      ref1 = [s1, s2];
      for (l = 0, len2 = ref1.length; l < len2; l++) {
        s = ref1[l];
        buf += `length=${s.length}\n`;
      }
      buf += "---------------------VALUES----------------------\n";
      buf += `${s1}\n\n`;
      buf += `${s2}\n`;
      h = "---------------------ANALYSIS & INTERPRETATION----------------------\n";
      switch (false) {
        //EASY
        // classify: completely different, pre-pended, appended, middle different
        case s1.length !== 0:
          buf += "s1 is empty";
          break;
        case s2.length !== 0:
          buf += "s2 is empty";
          break;
        case !(_ = endsDifferReport(s1, s2)):
          buf += _;
          break;
        case s1.toUpperCase() !== s2:
          buf += `${h}differ only by case`;
          break;
        case s1 !== s2.toUpperCase():
          buf += `${h}differ only by case`;
          break;
        case !HAS_INSERTED_TEXT_IN_MIDDLE(s1, s2):
          //EASY
          // 					# embedded
          // 					s1=aabbcc
          // 					s2=aacc
          buf += `${h}embedded TODO`;
          break;
        case !s1.endsWith(s2):
          buf += `${h}s1 ends with s2`;
          break;
        case !s1.startsWith(s2):
          buf += `${h}s1 startsWith s2`;
          break;
        case !s2.endsWith(s1):
          buf += `${h}s2 ends with s1`;
          break;
        case !s2.startsWith(s1):
          buf += `${h}s2 startsWith s1`;
          break;
        default:
          buf += `${h}some other difference`;
      }
      buf += "\n";
      buf += "---------------------HEX------------------\n";
      buf += `${HEX(s1)}\n\n`;
      buf += `${HEX(s1)}\n`;
      buf += "-------------------------------------------\n";
    } else {
      throw new Error("NOT STRINGS!");
    }
  }
  return buf;
};

F = function(o) {
  var O, item, results, v;
  O = require('./O');
  O.LOG(o);
  results = [];
  for (item in o) {
    v = o[item];
    results.push(console.log(item, v));
  }
  return results;
};

//OPTIONS: bPrependChar, maxBytes
//COOL: options map is cool because they can be passed into sub-functions
//EASY: number of bytes per line
//EASY: english SPACE or always hex 0x20
HEX = function(s, options = {}) {
  var a, buf, c, c2, css, hex, idx, special, unicode;
  a = [C.BACKSPACE, "BS", C.TAB, "TAB", C.LF, "LF", C.CR, "CR", C.SHIFT, "SHIFT", C.CTRL, "CTRL", C.ALT, "ALT", C.ESC, "ESC", C.SPACE, "SPACE", C.PAGE_UP, "PAGE_UP", C.PAGE_DOWN, "PAGE_DOWN", C.END, "END", C.HOME, "HOME", C.LEFT, "LEFT", C.UP, "UP", C.RIGHT, "RIGHT", C.DOWN, "DOWN", C.INSERT, "INSERT", C.DELETE, "DELETE", C.F1, "F1", C.F2, "F2", C.F3, "F3", C.F4, "F4", C.F5, "F5", C.F6, "F6", C.F7, "F7", C.F8, "F8", C.F9, "F9", C.F10, "F10", C.F11, "F11", C.F12, "F12"];
  special = Object.create(null);
  while (a.length > 0) {
    special["_" + a.shift()] = a.shift(); //H: why doesn't this work with "_"?   special appears to NEVER POPULATE
  }
  buf = "";
  idx = 0;
  a = s.split("");
  while (c = a.shift()) {
    unicode = c.charCodeAt(0);
    hex = unicode.toString(16); //PATTERN:HEX
    if (hex.length === 1) {
      hex = `0${hex}`;
    }
    if (c2 = special["_" + unicode]) {
      css = "c-special";
    } else {
      css = "c";
      c2 = c;
    }
    // buf += " #{idx}: #{c2} #{hex}"
    if (options.bPrependChar) {
      buf += `  ${c2} ${hex}`;
    } else {
      buf += `${hex}`;
    }
    idx++;
    if ((options.maxBytes != null) && options.maxBytes === idx) {
      break;
    }
  }
  return buf;
};

IS = function(v) {
  return Object.prototype.toString.call(v) === "[object String]";
};

module.exports = {
  autoTable: autoTable,
  CAP: CAP,
  COMPARE_REPORT: COMPARE_REPORT,
  DUMP: function(s, max = 256, bHEX) {
    var buf, len;
    if (IS(s)) {
      if (s == null) {
        len = 0;
        max = 0;
        s = "NULL";
      } else if (!s) {
        len = 0;
        max = 0;
        s = "EMPTY";
      } else {
        len = s.length;
        max = Math.min(s.length, max);
      }
      // ************ #{bHEX} #{max}
      buf = `${s} (${len})`;
      if (bHEX && max > 0) {
        buf += HEX(s);
      }
      return buf;
    } else {
      return ""; //H: what to do?
    }
  },
  //	DUMP_HTML: (s, max=256, bHEX) ->
  //		unless s?
  //			len = 0
  //			max = 0
  //			s = "NULL"
  //		else unless s
  //			len = 0
  //			max = 0
  //			s = "EMPTY"
  //		else
  //			len = s.length
  //			max = Math.min s.length, max

  //		buf = "<span class='dump-s'>#{s}</span>"
  //		buf += "<span class='dump-len'>#{len}</span>"

  //		if bHEX and max > 0
  //			a = [
  //				C.BACKSPACE
  //				"BS"
  //				C.TAB
  //				"TAB"
  //				C.LF
  //				"LF"
  //				C.CR
  //				"CR"
  //				C.SHIFT
  //				"SHIFT"
  //				C.CTRL
  //				"CTRL"
  //				C.ALT
  //				"ALT"
  //				C.ESC
  //				"ESC"
  //				C.SPACE
  //				"SPACE"
  //				C.PAGE_UP
  //				"PAGE_UP"
  //				C.PAGE_DOWN
  //				"PAGE_DOWN"
  //				C.END
  //				"END"
  //				C.HOME
  //				"HOME"
  //				C.LEFT
  //				"LEFT"
  //				C.UP
  //				"UP"
  //				C.RIGHT
  //				"RIGHT"
  //				C.DOWN
  //				"DOWN"
  //				C.INSERT
  //				"INSERT"
  //				C.DELETE
  //				"DELETE"
  //				C.F1
  //				"F1"
  //				C.F2
  //				"F2"
  //				C.F3
  //				"F3"
  //				C.F4
  //				"F4"
  //				C.F5
  //				"F5"
  //				C.F6
  //				"F6"
  //				C.F7
  //				"F7"
  //				C.F8
  //				"F8"
  //				C.F9
  //				"F9"
  //				C.F10
  //				"F10"
  //				C.F11
  //				"F11"
  //				C.F12
  //				"F12"
  //			]

  //			special = Object.create null

  //			while a.length > 0
  //				special["_"+a.shift()] = a.shift()	#H: why doesn't this work with "_"?   special appears to NEVER POPULATE

  //			idx = 0
  //			a = s.split ""
  //			while c = a.shift()
  //				unicode = c.charCodeAt 0

  //				hex = unicode.toString 16	#PATTERN:HEX
  //				if hex.length is 1
  //					hex = "0#{hex}"

  //				if c2 = special["_"+unicode]
  //					css = "c-special"
  //				else
  //					css = "c"
  //					c2 = c

  //				buf += "<span class='dump-idx'>#{idx++}</span><span class='dump-#{css}'>#{c2}</span><span class='dump-hex'>#{hex}</span>"
  //		buf
  enumCheck: function(target, css) {
    return `,${css},`.contains(`,${target},`);
  },
  HEX: HEX,
  IS: IS,
  //if ut
  s_ut: function() {
    var SUT, UT;
    UT = require('./ut');
    return (new (SUT = class SUT extends UT {
      run() {
        this.t("autoTable", function() {
          var _, a;
          a = [
            {
              peter: "peter",
              empty: null
            },
            {
              peter: 3.14159
            },
            {
              alvin: "alvin"
            }
          ];
          _ = autoTable(a, {
            bHeader: false
          });
          this.eq(_.length, 51);
          this.logg(trace.HUMAN, _);
          _ = autoTable(a);
          this.eq(_.length, 84);
          return this.logg(trace.HUMAN, _);
        });
        this.t("CAP", function() {
          return this.eq(CAP("peter"), "Peter");
        });
        this._t("F", function() { //EXPERIMENTAL
          return this.eq(F(`${{
            "abc": 10
          }}`), "");
        });
        this.t("IS", function() {
          this.assert(IS("hello"));
          return this.assert(!IS(4));
        });
        return this.s("COMPARE_REPORT", function() {
          this.t("differ only by case", function() {
            var s;
            s = COMPARE_REPORT("peter", "PETER");
            return this.logg(trace.HUMAN, s);
          });
          this._t("s1 is s2 but s1 has inserted characters in middle", function() {
            var s;
            s = COMPARE_REPORT("aa_THIS IS INSERTED_IN_MIDDLE_cc", "aacc");
            return this.logg(trace.HUMAN, s);
          });
          return this.t("ends differ", function() {
            var s;
            s = COMPARE_REPORT("abcdefg1234567", "abcdefgABC");
            return this.logg(trace.HUMAN, '^' + s);
          });
        });
      }

    })).run();
  }
};

//endif
