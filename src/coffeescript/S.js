// coffeescript.js: Generated by CoffeeScript GITLAB/lib 2.3.0
/*
V - String functions					*** PROJECT AGNOSTIC ***

WHAT: Node module

DESCRIPTION

FEATURES
-

NOTES
-

TODOs
- UT		#H

KNOWN BUGS:
-
*/
var C, CAP, COMPARE_REPORT, F, HEX, IS, V, autoTable, stringifySafe, trace;

C = require('./C');

trace = require('./trace');

V = require('./V');

stringifySafe = function(o) {
  var pn, s;
  if (o !== null && typeof o === 'object') {
    s = "";
    for (pn in o) {
      s += `${pn}=\${o[pn]} `;
    }
    return s;
  } else {
    return o;
  }
};

autoTable = function(data, opts = {
    bHeader: true
  }) {
  var O, bFound, buf, cn, columnMap, i, ignoreMap, j, len1, len2, o, pass, ref, row;
  //	data = Object.assign {}, data
  if (opts.grep) {
    console.log(`filter: ${opts.grep}`);
    opts.grep = opts.grep.toUpperCase();
  }
  ignoreMap = {};
  if (opts.ignore) {
    ref = opts.ignore.split(",");
    for (i = 0, len1 = ref.length; i < len1; i++) {
      cn = ref[i];
      //			console.log cn
      ignoreMap[cn] = true;
    }
  }
  O = require('./O');
  if (Array.isArray(data)) {
    data = data.slice(0);
    columnMap = new Map();
    pass = function() {
      var _, j, k, len2, results, row, s, v;
      results = [];
      for (j = 0, len2 = data.length; j < len2; j++) {
        row = data[j];
        if (V.type(row) === "object") {
          results.push((function() {
            var results1;
            results1 = [];
            for (k in row) {
              v = row[k];
              if (v) {
                s = "" + v;
              } else {
                s = "•";
              }
              if (_ = columnMap.get(k)) {
                results1.push(columnMap.set(k, Math.max(_, s.length)));
              } else {
                results1.push(columnMap.set(k, s.length));
              }
            }
            return results1;
          })());
        } else {
          throw "NOT-IMPL";
        }
      }
      return results;
    };
    //		columnMap.forEach (v,k) =>
    //			console.log "each", "k=#{k} v=#{v}"
    pass();
    if (opts.bHeader) {
      o = {};
      columnMap.forEach((v, k) => {
        if (!ignoreMap[k]) {
          return o[k] = k.toUpperCase();
        }
      });
      data.splice(0, 0, o);
      pass(); // re-compute max column widths including new header strings
    }
    buf = "";
    for (j = 0, len2 = data.length; j < len2; j++) {
      row = data[j];
      if (opts.grep) {
        bFound = false;
        columnMap.forEach((v, k) => {
          if (("" + row[k]).toUpperCase().includes(opts.grep)) {
            return bFound = true;
          }
        });
        if (!bFound) {
          continue;
        }
      }
      buf += "\n";
      if (V.type(row) === "object") {
        columnMap.forEach((v, k) => {
          if (!ignoreMap[k]) {
            //						console.log "k=#{k}"
            return buf += (row[k] ? "" + row[k] : "•").substring(0, v).padEnd(v + 1);
          }
        });
      }
    }
    //		console.log buf
    return buf;
  } else {
    throw "autoTable: NOT-IMP";
  }
};

//	process.exit 1
CAP = function(s) {
  return `${s[0].toUpperCase()}${(s.length > 1 ? s.slice(1).toLowerCase() : "")}`;
};

COMPARE_REPORT = function(s0, s1) { //H: string-oriented or value (V)-oriented?
  var bStrings, buf, i, j, l, len1, len2, len3, len4, len5, len6, m, n, p, ref, ref1, ref2, ref3, ref4, ref5, s;
  buf = '';
  if (s0 === s1) {
    buf = "values are the same";
  } else {
    bStrings = true;
    ref = [s0, s1];
    for (i = 0, len1 = ref.length; i < len1; i++) {
      s = ref[i];
      if (!IS(s)) {
        bStrings = false;
      }
    }
    if (bStrings) {
      buf += "---------------------LEN------------------\n";
      ref1 = [s0, s1];
      for (j = 0, len2 = ref1.length; j < len2; j++) {
        s = ref1[j];
        buf += `length=${s.length}\n`;
      }
      buf += "---------------------VALUES----------------------\n";
      ref2 = [s0, s1];
      for (l = 0, len3 = ref2.length; l < len3; l++) {
        s = ref2[l];
        // buf += "> arg#{i}: #{V.PAIR arguments[i]}\n\n"
        buf += `${V.PAIR(s)}\n\n`;
      }
      // classify: completely different, pre-pended, appended, middle different
      //			i = 0
      //			if s0.length
      buf += `---------------------IDENTICAL PORTION (UP TO [])----------------------\n`;
      ref3 = [s0, s1];
      for (m = 0, len4 = ref3.length; m < len4; m++) {
        s = ref3[m];
        buf += `${V.PAIR(s)}\n\n`;
      }
      buf += "---------------------HEX------------------\n";
      ref4 = [s0, s1];
      for (n = 0, len5 = ref4.length; n < len5; n++) {
        s = ref4[n];
        buf += `${HEX(s)}\n\n`;
      }
      buf += "-------------------------------------------\n";
    } else {
      ref5 = [s0, s1];
      for (p = 0, len6 = ref5.length; p < len6; p++) {
        s = ref5[p];
        buf += `${V.PAIR(s)}\n\n`;
      }
    }
  }
  return buf;
};

F = function(o) {
  var O, item, results, v;
  O = require('./O');
  O.LOG(o);
  results = [];
  for (item in o) {
    v = o[item];
    results.push(console.log(item, v));
  }
  return results;
};

HEX = function(s) {
  var a, buf, c, c2, css, hex, idx, special, unicode;
  a = [C.BACKSPACE, "BS", C.TAB, "TAB", C.LF, "LF", C.CR, "CR", C.SHIFT, "SHIFT", C.CTRL, "CTRL", C.ALT, "ALT", C.ESC, "ESC", C.SPACE, "SPACE", C.PAGE_UP, "PAGE_UP", C.PAGE_DOWN, "PAGE_DOWN", C.END, "END", C.HOME, "HOME", C.LEFT, "LEFT", C.UP, "UP", C.RIGHT, "RIGHT", C.DOWN, "DOWN", C.INSERT, "INSERT", C.DELETE, "DELETE", C.F1, "F1", C.F2, "F2", C.F3, "F3", C.F4, "F4", C.F5, "F5", C.F6, "F6", C.F7, "F7", C.F8, "F8", C.F9, "F9", C.F10, "F10", C.F11, "F11", C.F12, "F12"];
  special = Object.create(null);
  while (a.length > 0) {
    special["_" + a.shift()] = a.shift(); //H: why doesn't this work with "_"?   special appears to NEVER POPULATE
  }
  buf = "";
  idx = 0;
  a = s.split("");
  while (c = a.shift()) {
    unicode = c.charCodeAt(0);
    hex = unicode.toString(16); //PATTERN:HEX
    if (hex.length === 1) {
      hex = `0${hex}`;
    }
    if (c2 = special["_" + unicode]) {
      css = "c-special";
    } else {
      css = "c";
      c2 = c;
    }
    //				buf += " #{idx++}: #{c2} #{hex}"
    buf += `  ${c2} ${hex}`;
  }
  return buf;
};

IS = function(v) {
  return Object.prototype.toString.call(v) === "[object String]";
};

module.exports = {
  //if ut
  s_ut: function() {
    var SUT, UT;
    UT = require('./UT');
    return (new (SUT = class SUT extends UT {
      run() {
        this.t("autoTable", function() {
          var _, a;
          a = [
            {
              peter: "peter",
              empty: null
            },
            {
              peter: 3.14159
            },
            {
              alvin: "alvin"
            }
          ];
          _ = autoTable(a, {
            bHeader: false
          });
          this.eq(_.length, 51);
          this.logg(trace.HUMAN, _);
          _ = autoTable(a);
          this.eq(_.length, 84);
          return this.logg(trace.HUMAN, _);
        });
        this.t("CAP", function() {
          return this.eq(CAP("peter"), "Peter");
        });
        this._t("F", function() { //EXPERIMENTAL
          return this.eq(F(`${{
            "abc": 10
          }}`), "");
        });
        return this.t("IS", function() {
          this.assert(IS("hello"));
          return this.assert(!IS(4));
        });
      }

    })).run();
  },
  //endif
  autoTable: autoTable,
  CAP: CAP,
  COMPARE_REPORT: COMPARE_REPORT,
  DUMP: function(s, max = 256, bHEX) {
    var a, buf, c, c2, css, hex, idx, len, special, unicode;
    if (IS(s)) {
      if (s == null) {
        len = 0;
        max = 0;
        s = "NULL";
      } else if (!s) {
        len = 0;
        max = 0;
        s = "EMPTY";
      } else {
        len = s.length;
        max = Math.min(s.length, max);
      }
      // ************ #{bHEX} #{max}
      buf = `${s} (${len})`;
      if (bHEX && max > 0) {
        a = [C.BACKSPACE, "BS", C.TAB, "TAB", C.LF, "LF", C.CR, "CR", C.SHIFT, "SHIFT", C.CTRL, "CTRL", C.ALT, "ALT", C.ESC, "ESC", C.SPACE, "SPACE", C.PAGE_UP, "PAGE_UP", C.PAGE_DOWN, "PAGE_DOWN", C.END, "END", C.HOME, "HOME", C.LEFT, "LEFT", C.UP, "UP", C.RIGHT, "RIGHT", C.DOWN, "DOWN", C.INSERT, "INSERT", C.DELETE, "DELETE", C.F1, "F1", C.F2, "F2", C.F3, "F3", C.F4, "F4", C.F5, "F5", C.F6, "F6", C.F7, "F7", C.F8, "F8", C.F9, "F9", C.F10, "F10", C.F11, "F11", C.F12, "F12"];
        special = Object.create(null);
        while (a.length > 0) {
          special["_" + a.shift()] = a.shift(); //H: why doesn't this work with "_"?   special appears to NEVER POPULATE
        }
        idx = 0;
        a = s.split("");
        while (c = a.shift()) {
          unicode = c.charCodeAt(0);
          hex = unicode.toString(16); //PATTERN:HEX
          if (hex.length === 1) {
            hex = `0${hex}`;
          }
          if (c2 = special["_" + unicode]) {
            css = "c-special";
          } else {
            css = "c";
            c2 = c;
          }
          //				buf += " #{idx++}: #{c2} #{hex}"
          buf += `  ${c2} ${hex}`;
        }
      }
      return buf;
    } else {
      return ""; //H: what to do?
    }
  },
  //	DUMP_HTML: (s, max=256, bHEX) ->
  //		unless s?
  //			len = 0
  //			max = 0
  //			s = "NULL"
  //		else unless s
  //			len = 0
  //			max = 0
  //			s = "EMPTY"
  //		else
  //			len = s.length
  //			max = Math.min s.length, max

  //		buf = "<span class='dump-s'>#{s}</span>"
  //		buf += "<span class='dump-len'>#{len}</span>"

  //		if bHEX and max > 0
  //			a = [
  //				C.BACKSPACE
  //				"BS"
  //				C.TAB
  //				"TAB"
  //				C.LF
  //				"LF"
  //				C.CR
  //				"CR"
  //				C.SHIFT
  //				"SHIFT"
  //				C.CTRL
  //				"CTRL"
  //				C.ALT
  //				"ALT"
  //				C.ESC
  //				"ESC"
  //				C.SPACE
  //				"SPACE"
  //				C.PAGE_UP
  //				"PAGE_UP"
  //				C.PAGE_DOWN
  //				"PAGE_DOWN"
  //				C.END
  //				"END"
  //				C.HOME
  //				"HOME"
  //				C.LEFT
  //				"LEFT"
  //				C.UP
  //				"UP"
  //				C.RIGHT
  //				"RIGHT"
  //				C.DOWN
  //				"DOWN"
  //				C.INSERT
  //				"INSERT"
  //				C.DELETE
  //				"DELETE"
  //				C.F1
  //				"F1"
  //				C.F2
  //				"F2"
  //				C.F3
  //				"F3"
  //				C.F4
  //				"F4"
  //				C.F5
  //				"F5"
  //				C.F6
  //				"F6"
  //				C.F7
  //				"F7"
  //				C.F8
  //				"F8"
  //				C.F9
  //				"F9"
  //				C.F10
  //				"F10"
  //				C.F11
  //				"F11"
  //				C.F12
  //				"F12"
  //			]

  //			special = Object.create null

  //			while a.length > 0
  //				special["_"+a.shift()] = a.shift()	#H: why doesn't this work with "_"?   special appears to NEVER POPULATE

  //			idx = 0
  //			a = s.split ""
  //			while c = a.shift()
  //				unicode = c.charCodeAt 0

  //				hex = unicode.toString 16	#PATTERN:HEX
  //				if hex.length is 1
  //					hex = "0#{hex}"

  //				if c2 = special["_"+unicode]
  //					css = "c-special"
  //				else
  //					css = "c"
  //					c2 = c

  //				buf += "<span class='dump-idx'>#{idx++}</span><span class='dump-#{css}'>#{c2}</span><span class='dump-hex'>#{hex}</span>"
  //		buf
  enumCheck: function(target, css) {
    return `,${css},`.contains(`,${target},`);
  },
  HEX: HEX,
  IS: IS
};
