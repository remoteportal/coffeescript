// coffeescript.js: Generated by CoffeeScript GITLAB/lib 2.3.0
var O, lg, log, process, trace;

O = require('./O');

trace = require('./trace');

log = function(line) {
  return process.stdout.write(line + '\n');
};

log = function(line) {
  return console.log(line + '\n');
};

lg = function(line) {
  return console.log(line);
};

process = function(code, ENV = {}) {
  var _, a, arg, i, j, len, line, lines, name, req, stack;
  //	log "process"
  code = code.toString();
  //	log "FILE: SRC1: #{code}\n"
  a = [];
  stack = [];
  name = null;
  arg = function(line) {
    var tokens;
    tokens = line.split(' ');
    //		log "arg: #{tokens[1]}"
    return tokens[1];
  };
  req = {
    bGo: 1 // 0=off 1=on
  };
  lines = code.split('\n');
  for (i = j = 0, len = lines.length; j < len; i = ++j) {
    line = lines[i];
    switch (false) {
      //		line = line.replace /Charles/, 'Christmas'
      case line.slice(0, 3) !== "#if":
        //				req.bGo
        stack.push(req);
        req = Object.assign({}, req);
        req.bFlipOnElse = false;
        if (req.bGo) {
          req.bFlipOnElse = true;
          name = arg(line);
          req.bGo = ENV[name];
        }
        break;
      //				else
      //					req[] = true
      //					req.bIf = true
      //					lg "if:req=#{JSON.stringify req}"
      case line.slice(0, 5) !== "#else":
        if (req.bFlipOnElse) {
          req.bGo = !req.bGo;
        }
        break;
      case line.slice(0, 6) !== "#endif":
        req = stack.pop();
        break;
      default:
        if (req.bGo) {
          a.push(line);
        }
    }
  }
  //				unless req.bSuppress
  //					if O.CNT_OWN(req) is 0
  //	#					log "empty"
  //						a.push line
  //					else
  //	# make sure all requirements satisfied
  //						bGo = true
  //						for k of req
  //							log "found #{k}"
  //							if req[k]
  //	#							log "eval"
  //								bGo &= ENV[k]
  //							log "bGo=#{bGo}"
  //						if bGo
  //							if req.last is "if"	#HACK
  //								log "req.bSuppressElse = true"
  //								req.bSuppressElse = true
  //							a.push line
  //						else
  //							lg "SKIP: #{line}"
  //		lines[i] = line
  //		log "LINE: #{line}"
  _ = a.join('\n');
  //	log "========== AFTER"
  //	log _
  return _;
};

module.exports = {
  //if ut
  s_ut: function() {
    var PeterUT, UT;
    UT = require('./UT');
    return (new (PeterUT = class PeterUT extends UT {
      run() {
        return this.s("process", function() {
          var fn;
          fn = (c1, c2, ENV, that) => {
            var rv;
            //						console.log "====================BEFORE================ ENV=#{JSON.stringify ENV}"
            //						console.log c1
            //						console.log "-----------------------------------------------"
            //						console.log c2
            //						console.log "-----------------------------------------------"
            rv = process(c1, ENV);
            return that.eq(rv, c2);
          };
          this.t("trivial", function() {
            var c1, c2;
            c1 = "abc\ndef";
            c2 = "abc\ndef";
            return fn(c1, c2, {}, this);
          });
          this.t("if: env=", function() {
            var c1, c2;
            c1 = "before\n#if rn\nthis is rn\n#else\nthis is NOT rn\n#endif\nafter";
            c2 = "before\nthis is NOT rn\nafter";
            return fn(c1, c2, {}, this);
          });
          this.T("if: env=rn", function() {
            var c1, c2;
            c1 = "before\n#if rn\nthis is rn\n#else\nthis is NOT rn\n#endif\nafter";
            c2 = "before\nthis is rn\nafter";
            return fn(c1, c2, {
              rn: true
            }, this);
          });
          return this.t("nested if: env=rn", function() {
            var c1, c2;
            c1 = "before\n#if rn\nthis is rn\n#else\nthis is NOT rn\n#endif\nafter";
            c2 = "before\nthis is NOT rn\nafter";
            return fn(c1, c2, {
              rn: false
            }, this);
          });
        });
      }

    })).run();
  },
  //endif
  process: process
};
